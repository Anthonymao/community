{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.string.includes.js\";\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n/**\n * Class responsible for all of the Selection-related operations on merged cells.\n *\n * @private\n * @class SelectionCalculations\n */\n\n\nvar SelectionCalculations = /*#__PURE__*/function () {\n  function SelectionCalculations(plugin) {\n    _classCallCheck(this, SelectionCalculations);\n    /**\n     * Reference to the Merge Cells plugin.\n     *\n     * @type {MergeCells}\n     */\n\n\n    this.plugin = plugin;\n    /**\n     * Reference to the Handsontable instance.\n     *\n     * @type {Handsontable}\n     */\n\n    this.hot = plugin.hot;\n    /**\n     * Class name used for fully selected merged cells.\n     *\n     * @type {string}\n     */\n\n    this.fullySelectedMergedCellClassName = 'fullySelectedMergedCell';\n  }\n  /**\n   * \"Snap\" the delta value according to defined merged cells. (In other words, compensate the rowspan -\n   * e.g. Going up with `delta.row = -1` over a merged cell with `rowspan = 3`, `delta.row` should change to `-3`.).\n   *\n   * @param {object} delta The delta object containing `row` and `col` properties.\n   * @param {CellRange} selectionRange The selection range.\n   * @param {object} mergedCell A merged cell object.\n   */\n\n\n  _createClass(SelectionCalculations, [{\n    key: \"snapDelta\",\n    value: function snapDelta(delta, selectionRange, mergedCell) {\n      var cellCoords = selectionRange.to;\n      var newRow = cellCoords.row + delta.row;\n      var newColumn = cellCoords.col + delta.col;\n\n      if (delta.row) {\n        this.jumpOverMergedCell(delta, mergedCell, newRow);\n      } else if (delta.col) {\n        this.jumpOverMergedCell(delta, mergedCell, newColumn);\n      }\n    }\n    /**\n     * \"Jump\" over the merged cell (compensate for the indexes within the merged cell to get past it).\n     *\n     * @private\n     * @param {object} delta The delta object.\n     * @param {MergedCellCoords} mergedCell The merge cell object.\n     * @param {number} newIndex New row/column index, created with the delta.\n     */\n\n  }, {\n    key: \"jumpOverMergedCell\",\n    value: function jumpOverMergedCell(delta, mergedCell, newIndex) {\n      var flatDelta = delta.row || delta.col;\n      var includesIndex = null;\n      var firstIndex = null;\n      var lastIndex = null;\n\n      if (delta.row) {\n        includesIndex = mergedCell.includesVertically(newIndex);\n        firstIndex = mergedCell.row;\n        lastIndex = mergedCell.getLastRow();\n      } else if (delta.col) {\n        includesIndex = mergedCell.includesHorizontally(newIndex);\n        firstIndex = mergedCell.col;\n        lastIndex = mergedCell.getLastColumn();\n      }\n\n      if (flatDelta === 0) {\n        return;\n      } else if (flatDelta > 0) {\n        if (includesIndex && newIndex !== firstIndex) {\n          flatDelta += lastIndex - newIndex + 1;\n        }\n      } else if (includesIndex && newIndex !== lastIndex) {\n        flatDelta -= newIndex - firstIndex + 1;\n      }\n\n      if (delta.row) {\n        delta.row = flatDelta;\n      } else if (delta.col) {\n        delta.col = flatDelta;\n      }\n    }\n    /**\n     * Get a selection range with `to` property incremented by the provided delta.\n     *\n     * @param {CellRange} oldSelectionRange The base selection range.\n     * @param {object} delta The delta object with `row` and `col` properties.\n     * @returns {CellRange} A new `CellRange` object.\n     */\n\n  }, {\n    key: \"getUpdatedSelectionRange\",\n    value: function getUpdatedSelectionRange(oldSelectionRange, delta) {\n      return this.hot._createCellRange(oldSelectionRange.highlight, oldSelectionRange.from, this.hot._createCellCoords(oldSelectionRange.to.row + delta.row, oldSelectionRange.to.col + delta.col));\n    }\n    /**\n     * Generate an additional class name for the entirely-selected merged cells.\n     *\n     * @param {number} currentRow Visual row index of the currently processed cell.\n     * @param {number} currentColumn Visual column index of the currently cell.\n     * @param {Array} cornersOfSelection Array of the current selection in a form of `[startRow, startColumn, endRow, endColumn]`.\n     * @param {number|undefined} layerLevel Number indicating which layer of selection is currently processed.\n     * @returns {string|undefined} A `String`, which will act as an additional `className` to be added to the currently processed cell.\n     */\n\n  }, {\n    key: \"getSelectedMergedCellClassName\",\n    value: function getSelectedMergedCellClassName(currentRow, currentColumn, cornersOfSelection, layerLevel) {\n      var startRow = Math.min(cornersOfSelection[0], cornersOfSelection[2]);\n      var startColumn = Math.min(cornersOfSelection[1], cornersOfSelection[3]);\n      var endRow = Math.max(cornersOfSelection[0], cornersOfSelection[2]);\n      var endColumn = Math.max(cornersOfSelection[1], cornersOfSelection[3]);\n\n      if (layerLevel === void 0) {\n        return;\n      }\n\n      var isFirstRenderableMergedCell = this.plugin.mergedCellsCollection.isFirstRenderableMergedCell(currentRow, currentColumn); // We add extra classes just to the first renderable merged cell.\n\n      if (!isFirstRenderableMergedCell) {\n        return;\n      }\n\n      var mergedCell = this.plugin.mergedCellsCollection.get(currentRow, currentColumn);\n\n      if (!mergedCell) {\n        return;\n      }\n\n      var mergeRowEnd = mergedCell.getLastRow();\n      var mergeColumnEnd = mergedCell.getLastColumn();\n      var fullMergeAreaWithinSelection = startRow <= mergedCell.row && startColumn <= mergedCell.col && endRow >= mergeRowEnd && endColumn >= mergeColumnEnd;\n\n      if (fullMergeAreaWithinSelection) {\n        return \"\".concat(this.fullySelectedMergedCellClassName, \"-\").concat(layerLevel);\n      } else if (this.plugin.selectionCalculations.isMergeCellFullySelected(mergedCell, this.plugin.hot.getSelectedRange())) {\n        // eslint-disable-line max-len\n        return \"\".concat(this.fullySelectedMergedCellClassName, \"-multiple\");\n      }\n    }\n    /**\n     * Check if the provided merged cell is fully selected (by one or many layers of selection).\n     *\n     * @param {MergedCellCoords} mergedCell The merged cell to be processed.\n     * @param {CellRange[]} selectionRangesArray Array of selection ranges.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isMergeCellFullySelected\",\n    value: function isMergeCellFullySelected(mergedCell, selectionRangesArray) {\n      var mergedCellIndividualCoords = [];\n\n      if (!selectionRangesArray || !mergedCell) {\n        return false;\n      }\n\n      for (var r = 0; r < mergedCell.rowspan; r += 1) {\n        for (var c = 0; c < mergedCell.colspan; c += 1) {\n          mergedCellIndividualCoords.push(this.hot._createCellCoords(mergedCell.row + r, mergedCell.col + c));\n        }\n      }\n\n      for (var i = 0; i < mergedCellIndividualCoords.length; i += 1) {\n        var insideSelections = [];\n\n        for (var s = 0; s < selectionRangesArray.length; s += 1) {\n          insideSelections[s] = selectionRangesArray[s].includes(mergedCellIndividualCoords[i]);\n        }\n\n        if (!insideSelections.includes(true)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n    /**\n     * Generate an array of the entirely-selected merged cells' class names.\n     *\n     * @returns {string[]} An `Array` of `String`s. Each of these strings will act like class names to be removed from all the cells in the table.\n     */\n\n  }, {\n    key: \"getSelectedMergedCellClassNameToRemove\",\n    value: function getSelectedMergedCellClassNameToRemove() {\n      var classNames = [];\n\n      for (var i = 0; i <= 7; i += 1) {\n        classNames.push(\"\".concat(this.fullySelectedMergedCellClassName, \"-\").concat(i));\n      }\n\n      classNames.push(\"\".concat(this.fullySelectedMergedCellClassName, \"-multiple\"));\n      return classNames;\n    }\n  }]);\n\n  return SelectionCalculations;\n}();\n\nexport default SelectionCalculations;","map":{"version":3,"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","SelectionCalculations","plugin","hot","fullySelectedMergedCellClassName","value","snapDelta","delta","selectionRange","mergedCell","cellCoords","to","newRow","row","newColumn","col","jumpOverMergedCell","newIndex","flatDelta","includesIndex","firstIndex","lastIndex","includesVertically","getLastRow","includesHorizontally","getLastColumn","getUpdatedSelectionRange","oldSelectionRange","_createCellRange","highlight","from","_createCellCoords","getSelectedMergedCellClassName","currentRow","currentColumn","cornersOfSelection","layerLevel","startRow","Math","min","startColumn","endRow","max","endColumn","isFirstRenderableMergedCell","mergedCellsCollection","get","mergeRowEnd","mergeColumnEnd","fullMergeAreaWithinSelection","concat","selectionCalculations","isMergeCellFullySelected","getSelectedRange","selectionRangesArray","mergedCellIndividualCoords","r","rowspan","c","colspan","push","insideSelections","s","includes","getSelectedMergedCellClassNameToRemove","classNames"],"sources":["/home/ubuntu/community/vue-web/node_modules/handsontable/plugins/mergeCells/calculations/selection.mjs"],"sourcesContent":["import \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.string.includes.js\";\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n/**\n * Class responsible for all of the Selection-related operations on merged cells.\n *\n * @private\n * @class SelectionCalculations\n */var SelectionCalculations = /*#__PURE__*/function () {\n  function SelectionCalculations(plugin) {\n    _classCallCheck(this, SelectionCalculations);\n    /**\n     * Reference to the Merge Cells plugin.\n     *\n     * @type {MergeCells}\n     */\n    this.plugin = plugin;\n    /**\n     * Reference to the Handsontable instance.\n     *\n     * @type {Handsontable}\n     */\n    this.hot = plugin.hot;\n    /**\n     * Class name used for fully selected merged cells.\n     *\n     * @type {string}\n     */\n    this.fullySelectedMergedCellClassName = 'fullySelectedMergedCell';\n  }\n\n  /**\n   * \"Snap\" the delta value according to defined merged cells. (In other words, compensate the rowspan -\n   * e.g. Going up with `delta.row = -1` over a merged cell with `rowspan = 3`, `delta.row` should change to `-3`.).\n   *\n   * @param {object} delta The delta object containing `row` and `col` properties.\n   * @param {CellRange} selectionRange The selection range.\n   * @param {object} mergedCell A merged cell object.\n   */\n  _createClass(SelectionCalculations, [{\n    key: \"snapDelta\",\n    value: function snapDelta(delta, selectionRange, mergedCell) {\n      var cellCoords = selectionRange.to;\n      var newRow = cellCoords.row + delta.row;\n      var newColumn = cellCoords.col + delta.col;\n      if (delta.row) {\n        this.jumpOverMergedCell(delta, mergedCell, newRow);\n      } else if (delta.col) {\n        this.jumpOverMergedCell(delta, mergedCell, newColumn);\n      }\n    }\n\n    /**\n     * \"Jump\" over the merged cell (compensate for the indexes within the merged cell to get past it).\n     *\n     * @private\n     * @param {object} delta The delta object.\n     * @param {MergedCellCoords} mergedCell The merge cell object.\n     * @param {number} newIndex New row/column index, created with the delta.\n     */\n  }, {\n    key: \"jumpOverMergedCell\",\n    value: function jumpOverMergedCell(delta, mergedCell, newIndex) {\n      var flatDelta = delta.row || delta.col;\n      var includesIndex = null;\n      var firstIndex = null;\n      var lastIndex = null;\n      if (delta.row) {\n        includesIndex = mergedCell.includesVertically(newIndex);\n        firstIndex = mergedCell.row;\n        lastIndex = mergedCell.getLastRow();\n      } else if (delta.col) {\n        includesIndex = mergedCell.includesHorizontally(newIndex);\n        firstIndex = mergedCell.col;\n        lastIndex = mergedCell.getLastColumn();\n      }\n      if (flatDelta === 0) {\n        return;\n      } else if (flatDelta > 0) {\n        if (includesIndex && newIndex !== firstIndex) {\n          flatDelta += lastIndex - newIndex + 1;\n        }\n      } else if (includesIndex && newIndex !== lastIndex) {\n        flatDelta -= newIndex - firstIndex + 1;\n      }\n      if (delta.row) {\n        delta.row = flatDelta;\n      } else if (delta.col) {\n        delta.col = flatDelta;\n      }\n    }\n\n    /**\n     * Get a selection range with `to` property incremented by the provided delta.\n     *\n     * @param {CellRange} oldSelectionRange The base selection range.\n     * @param {object} delta The delta object with `row` and `col` properties.\n     * @returns {CellRange} A new `CellRange` object.\n     */\n  }, {\n    key: \"getUpdatedSelectionRange\",\n    value: function getUpdatedSelectionRange(oldSelectionRange, delta) {\n      return this.hot._createCellRange(oldSelectionRange.highlight, oldSelectionRange.from, this.hot._createCellCoords(oldSelectionRange.to.row + delta.row, oldSelectionRange.to.col + delta.col));\n    }\n\n    /**\n     * Generate an additional class name for the entirely-selected merged cells.\n     *\n     * @param {number} currentRow Visual row index of the currently processed cell.\n     * @param {number} currentColumn Visual column index of the currently cell.\n     * @param {Array} cornersOfSelection Array of the current selection in a form of `[startRow, startColumn, endRow, endColumn]`.\n     * @param {number|undefined} layerLevel Number indicating which layer of selection is currently processed.\n     * @returns {string|undefined} A `String`, which will act as an additional `className` to be added to the currently processed cell.\n     */\n  }, {\n    key: \"getSelectedMergedCellClassName\",\n    value: function getSelectedMergedCellClassName(currentRow, currentColumn, cornersOfSelection, layerLevel) {\n      var startRow = Math.min(cornersOfSelection[0], cornersOfSelection[2]);\n      var startColumn = Math.min(cornersOfSelection[1], cornersOfSelection[3]);\n      var endRow = Math.max(cornersOfSelection[0], cornersOfSelection[2]);\n      var endColumn = Math.max(cornersOfSelection[1], cornersOfSelection[3]);\n      if (layerLevel === void 0) {\n        return;\n      }\n      var isFirstRenderableMergedCell = this.plugin.mergedCellsCollection.isFirstRenderableMergedCell(currentRow, currentColumn);\n\n      // We add extra classes just to the first renderable merged cell.\n      if (!isFirstRenderableMergedCell) {\n        return;\n      }\n      var mergedCell = this.plugin.mergedCellsCollection.get(currentRow, currentColumn);\n      if (!mergedCell) {\n        return;\n      }\n      var mergeRowEnd = mergedCell.getLastRow();\n      var mergeColumnEnd = mergedCell.getLastColumn();\n      var fullMergeAreaWithinSelection = startRow <= mergedCell.row && startColumn <= mergedCell.col && endRow >= mergeRowEnd && endColumn >= mergeColumnEnd;\n      if (fullMergeAreaWithinSelection) {\n        return \"\".concat(this.fullySelectedMergedCellClassName, \"-\").concat(layerLevel);\n      } else if (this.plugin.selectionCalculations.isMergeCellFullySelected(mergedCell, this.plugin.hot.getSelectedRange())) {\n        // eslint-disable-line max-len\n        return \"\".concat(this.fullySelectedMergedCellClassName, \"-multiple\");\n      }\n    }\n\n    /**\n     * Check if the provided merged cell is fully selected (by one or many layers of selection).\n     *\n     * @param {MergedCellCoords} mergedCell The merged cell to be processed.\n     * @param {CellRange[]} selectionRangesArray Array of selection ranges.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isMergeCellFullySelected\",\n    value: function isMergeCellFullySelected(mergedCell, selectionRangesArray) {\n      var mergedCellIndividualCoords = [];\n      if (!selectionRangesArray || !mergedCell) {\n        return false;\n      }\n      for (var r = 0; r < mergedCell.rowspan; r += 1) {\n        for (var c = 0; c < mergedCell.colspan; c += 1) {\n          mergedCellIndividualCoords.push(this.hot._createCellCoords(mergedCell.row + r, mergedCell.col + c));\n        }\n      }\n      for (var i = 0; i < mergedCellIndividualCoords.length; i += 1) {\n        var insideSelections = [];\n        for (var s = 0; s < selectionRangesArray.length; s += 1) {\n          insideSelections[s] = selectionRangesArray[s].includes(mergedCellIndividualCoords[i]);\n        }\n        if (!insideSelections.includes(true)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Generate an array of the entirely-selected merged cells' class names.\n     *\n     * @returns {string[]} An `Array` of `String`s. Each of these strings will act like class names to be removed from all the cells in the table.\n     */\n  }, {\n    key: \"getSelectedMergedCellClassNameToRemove\",\n    value: function getSelectedMergedCellClassNameToRemove() {\n      var classNames = [];\n      for (var i = 0; i <= 7; i += 1) {\n        classNames.push(\"\".concat(this.fullySelectedMergedCellClassName, \"-\").concat(i));\n      }\n      classNames.push(\"\".concat(this.fullySelectedMergedCellClassName, \"-multiple\"));\n      return classNames;\n    }\n  }]);\n  return SelectionCalculations;\n}();\nexport default SelectionCalculations;"],"mappings":"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"},"metadata":{},"sourceType":"module"}