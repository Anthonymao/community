{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.includes.js\";\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/es.array.reverse.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.weak-map.js\";\nimport \"core-js/modules/es.object.set-prototype-of.js\";\nimport \"core-js/modules/es.object.get-prototype-of.js\";\nimport \"core-js/modules/es.reflect.construct.js\";\nimport \"core-js/modules/es.reflect.get.js\";\nimport \"core-js/modules/es.object.get-own-property-descriptor.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.object.get-own-property-descriptors.js\";\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nfunction _get() {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get.bind();\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(arguments.length < 3 ? target : receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get.apply(this, arguments);\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) {\n  _checkPrivateRedeclaration(obj, privateMap);\n\n  privateMap.set(obj, value);\n}\n\nfunction _checkPrivateRedeclaration(obj, privateCollection) {\n  if (privateCollection.has(obj)) {\n    throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n  }\n}\n\nfunction _classPrivateFieldSet(receiver, privateMap, value) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\");\n\n  _classApplyDescriptorSet(receiver, descriptor, value);\n\n  return value;\n}\n\nfunction _classApplyDescriptorSet(receiver, descriptor, value) {\n  if (descriptor.set) {\n    descriptor.set.call(receiver, value);\n  } else {\n    if (!descriptor.writable) {\n      throw new TypeError(\"attempted to set read only private field\");\n    }\n\n    descriptor.value = value;\n  }\n}\n\nfunction _classPrivateFieldGet(receiver, privateMap) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\");\n\n  return _classApplyDescriptorGet(receiver, descriptor);\n}\n\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to \" + action + \" private field on non-instance\");\n  }\n\n  return privateMap.get(receiver);\n}\n\nfunction _classApplyDescriptorGet(receiver, descriptor) {\n  if (descriptor.get) {\n    return descriptor.get.call(receiver);\n  }\n\n  return descriptor.value;\n}\n\nimport { BasePlugin } from \"../base/index.mjs\";\nimport staticRegister from \"../../utils/staticRegister.mjs\";\nimport { error, warn } from \"../../helpers/console.mjs\";\nimport { isNumeric } from \"../../helpers/number.mjs\";\nimport { isDefined, isUndefined } from \"../../helpers/mixed.mjs\";\nimport { setupEngine, setupSheet, unregisterEngine, getRegisteredHotInstances } from \"./engine/register.mjs\";\nimport { isEscapedFormulaExpression, unescapeFormulaExpression } from \"./utils.mjs\";\nimport { getEngineSettingsWithOverrides } from \"./engine/settings.mjs\";\nimport { isArrayOfArrays } from \"../../helpers/data.mjs\";\nimport { toUpperCaseFirst } from \"../../helpers/string.mjs\";\nimport Hooks from \"../../pluginHooks.mjs\";\nexport var PLUGIN_KEY = 'formulas';\nexport var PLUGIN_PRIORITY = 260;\nvar ROW_MOVE_UNDO_REDO_NAME = 'row_move';\nHooks.getSingleton().register('afterNamedExpressionAdded');\nHooks.getSingleton().register('afterNamedExpressionRemoved');\nHooks.getSingleton().register('afterSheetAdded');\nHooks.getSingleton().register('afterSheetRemoved');\nHooks.getSingleton().register('afterSheetRenamed');\nHooks.getSingleton().register('afterFormulasValuesUpdate'); // This function will be used for detecting changes coming from the `UndoRedo` plugin. This kind of change won't be\n// handled by whole body of listeners and therefore won't change undo/redo stack inside engine provided by HyperFormula.\n// HyperFormula's `undo` and `redo` methods will do it instead. Please keep in mind that undo/redo stacks inside\n// instances of Handsontable and HyperFormula should be synced (number of actions should be the same).\n\nvar isBlockedSource = function isBlockedSource(source) {\n  return source === 'UndoRedo.undo' || source === 'UndoRedo.redo' || source === 'auto';\n};\n/**\n * This plugin allows you to perform Excel-like calculations in your business applications. It does it by an\n * integration with our other product, [HyperFormula](https://github.com/handsontable/hyperformula/), which is a\n * powerful calculation engine with an extensive number of features.\n *\n * To test out HyperFormula, see [this guide](@/guides/formulas/formula-calculation.md#available-functions).\n *\n * @plugin Formulas\n * @class Formulas\n */\n\n\nvar _internalOperationPending = /*#__PURE__*/new WeakMap();\n\nvar _hotWasInitializedWithEmptyData = /*#__PURE__*/new WeakMap();\n\nvar _engineListeners = /*#__PURE__*/new WeakMap();\n\nexport var Formulas = /*#__PURE__*/function (_BasePlugin) {\n  _inherits(Formulas, _BasePlugin);\n\n  var _super = _createSuper(Formulas);\n\n  function Formulas() {\n    var _this;\n\n    _classCallCheck(this, Formulas);\n\n    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {\n      _args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(_args));\n\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _internalOperationPending, {\n      writable: true,\n      value: false\n    });\n\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _hotWasInitializedWithEmptyData, {\n      writable: true,\n      value: false\n    });\n\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _engineListeners, {\n      writable: true,\n      value: [['valuesUpdated', function () {\n        var _this2;\n\n        return (_this2 = _this).onEngineValuesUpdated.apply(_this2, arguments);\n      }], ['namedExpressionAdded', function () {\n        var _this3;\n\n        return (_this3 = _this).onEngineNamedExpressionsAdded.apply(_this3, arguments);\n      }], ['namedExpressionRemoved', function () {\n        var _this4;\n\n        return (_this4 = _this).onEngineNamedExpressionsRemoved.apply(_this4, arguments);\n      }], ['sheetAdded', function () {\n        var _this5;\n\n        return (_this5 = _this).onEngineSheetAdded.apply(_this5, arguments);\n      }], ['sheetRenamed', function () {\n        var _this6;\n\n        return (_this6 = _this).onEngineSheetRenamed.apply(_this6, arguments);\n      }], ['sheetRemoved', function () {\n        var _this7;\n\n        return (_this7 = _this).onEngineSheetRemoved.apply(_this7, arguments);\n      }]]\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"staticRegister\", staticRegister('formulas'));\n\n    _defineProperty(_assertThisInitialized(_this), \"engine\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"sheetName\", null);\n\n    return _this;\n  }\n\n  _createClass(Formulas, [{\n    key: \"sheetId\",\n    get:\n    /**\n     * HyperFormula's sheet id.\n     *\n     * @type {number|null}\n     */\n    function get() {\n      return this.sheetName === null ? null : this.engine.getSheetId(this.sheetName);\n    }\n    /**\n     * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\n     * hook and if it returns `true` then the {@link Formulas#enablePlugin} method is called.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isEnabled\",\n    value: function isEnabled() {\n      /* eslint-disable no-unneeded-ternary */\n      return this.hot.getSettings()[PLUGIN_KEY] ? true : false;\n    }\n    /**\n     * Enables the plugin functionality for this Handsontable instance.\n     */\n\n  }, {\n    key: \"enablePlugin\",\n    value: function enablePlugin() {\n      var _setupEngine,\n          _this8 = this;\n\n      if (this.enabled) {\n        return;\n      }\n\n      this.engine = (_setupEngine = setupEngine(this.hot)) !== null && _setupEngine !== void 0 ? _setupEngine : this.engine;\n\n      if (!this.engine) {\n        warn('Missing the required `engine` key in the Formulas settings. Please fill it with either an' + ' engine class or an engine instance.');\n        return;\n      } // Useful for disabling -> enabling the plugin using `updateSettings` or the API.\n\n\n      if (this.sheetName !== null && !this.engine.doesSheetExist(this.sheetName)) {\n        var newSheetName = this.addSheet(this.sheetName, this.hot.getSourceDataArray());\n\n        if (newSheetName !== false) {\n          this.sheetName = newSheetName;\n        }\n      }\n\n      this.addHook('beforeLoadData', function () {\n        return _this8.onBeforeLoadData.apply(_this8, arguments);\n      });\n      this.addHook('afterLoadData', function () {\n        return _this8.onAfterLoadData.apply(_this8, arguments);\n      });\n      this.addHook('modifyData', function () {\n        return _this8.onModifyData.apply(_this8, arguments);\n      });\n      this.addHook('modifySourceData', function () {\n        return _this8.onModifySourceData.apply(_this8, arguments);\n      });\n      this.addHook('beforeValidate', function () {\n        return _this8.onBeforeValidate.apply(_this8, arguments);\n      });\n      this.addHook('afterSetSourceDataAtCell', function () {\n        return _this8.onAfterSetSourceDataAtCell.apply(_this8, arguments);\n      });\n      this.addHook('afterSetDataAtCell', function () {\n        return _this8.onAfterSetDataAtCell.apply(_this8, arguments);\n      });\n      this.addHook('afterSetDataAtRowProp', function () {\n        return _this8.onAfterSetDataAtCell.apply(_this8, arguments);\n      });\n      this.addHook('beforeCreateRow', function () {\n        return _this8.onBeforeCreateRow.apply(_this8, arguments);\n      });\n      this.addHook('beforeCreateCol', function () {\n        return _this8.onBeforeCreateCol.apply(_this8, arguments);\n      });\n      this.addHook('afterCreateRow', function () {\n        return _this8.onAfterCreateRow.apply(_this8, arguments);\n      });\n      this.addHook('afterCreateCol', function () {\n        return _this8.onAfterCreateCol.apply(_this8, arguments);\n      });\n      this.addHook('beforeRemoveRow', function () {\n        return _this8.onBeforeRemoveRow.apply(_this8, arguments);\n      });\n      this.addHook('beforeRemoveCol', function () {\n        return _this8.onBeforeRemoveCol.apply(_this8, arguments);\n      });\n      this.addHook('afterRemoveRow', function () {\n        return _this8.onAfterRemoveRow.apply(_this8, arguments);\n      });\n      this.addHook('afterRemoveCol', function () {\n        return _this8.onAfterRemoveCol.apply(_this8, arguments);\n      }); // Handling undo actions on data just using HyperFormula's UndoRedo mechanism\n\n      this.addHook('beforeUndo', function (action) {\n        // TODO: Move action isn't handled by HyperFormula.\n        if ((action === null || action === void 0 ? void 0 : action.actionType) === ROW_MOVE_UNDO_REDO_NAME) {\n          return;\n        }\n\n        _this8.engine.undo();\n      }); // Handling redo actions on data just using HyperFormula's UndoRedo mechanism\n\n      this.addHook('beforeRedo', function (action) {\n        // TODO: Move action isn't handled by HyperFormula.\n        if ((action === null || action === void 0 ? void 0 : action.actionType) === ROW_MOVE_UNDO_REDO_NAME) {\n          return;\n        }\n\n        _this8.engine.redo();\n      });\n      this.addHook('afterDetachChild', function () {\n        return _this8.onAfterDetachChild.apply(_this8, arguments);\n      });\n      this.addHook('beforeAutofill', function () {\n        return _this8.onBeforeAutofill.apply(_this8, arguments);\n      });\n\n      _classPrivateFieldGet(this, _engineListeners).forEach(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            eventName = _ref2[0],\n            listener = _ref2[1];\n\n        return _this8.engine.on(eventName, listener);\n      });\n\n      _get(_getPrototypeOf(Formulas.prototype), \"enablePlugin\", this).call(this);\n    }\n    /**\n     * Disables the plugin functionality for this Handsontable instance.\n     */\n\n  }, {\n    key: \"disablePlugin\",\n    value: function disablePlugin() {\n      var _this9 = this;\n\n      _classPrivateFieldGet(this, _engineListeners).forEach(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n            eventName = _ref4[0],\n            listener = _ref4[1];\n\n        return _this9.engine.off(eventName, listener);\n      });\n\n      unregisterEngine(this.engine, this.hot);\n      this.engine = null;\n\n      _get(_getPrototypeOf(Formulas.prototype), \"disablePlugin\", this).call(this);\n    }\n    /**\n     * Triggered on `updateSettings`.\n     *\n     * @private\n     * @param {object} newSettings New set of settings passed to the `updateSettings` method.\n     */\n\n  }, {\n    key: \"updatePlugin\",\n    value: function updatePlugin(newSettings) {\n      this.engine.updateConfig(getEngineSettingsWithOverrides(this.hot.getSettings()));\n      var pluginSettings = this.hot.getSettings()[PLUGIN_KEY];\n\n      if (isDefined(pluginSettings) && isDefined(pluginSettings.sheetName) && pluginSettings.sheetName !== this.sheetName) {\n        this.switchSheet(pluginSettings.sheetName);\n      } // If no data was passed to the `updateSettings` method and no sheet is connected to the instance -> create a\n      // new sheet using the currently used data. Otherwise, it will be handled by the `afterLoadData` call.\n\n\n      if (!newSettings.data && this.sheetName === null) {\n        var sheetName = this.hot.getSettings()[PLUGIN_KEY].sheetName;\n\n        if (sheetName && this.engine.doesSheetExist(sheetName)) {\n          this.switchSheet(this.sheetName);\n        } else {\n          this.sheetName = this.addSheet(sheetName !== null && sheetName !== void 0 ? sheetName : void 0, this.hot.getSourceDataArray());\n        }\n      }\n\n      _get(_getPrototypeOf(Formulas.prototype), \"updatePlugin\", this).call(this, newSettings);\n    }\n    /**\n     * Destroys the plugin instance.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var _this10 = this;\n\n      _classPrivateFieldGet(this, _engineListeners).forEach(function (_ref5) {\n        var _this10$engine;\n\n        var _ref6 = _slicedToArray(_ref5, 2),\n            eventName = _ref6[0],\n            listener = _ref6[1];\n\n        return (_this10$engine = _this10.engine) === null || _this10$engine === void 0 ? void 0 : _this10$engine.off(eventName, listener);\n      });\n\n      _classPrivateFieldSet(this, _engineListeners, null);\n\n      unregisterEngine(this.engine, this.hot);\n      this.engine = null;\n\n      _get(_getPrototypeOf(Formulas.prototype), \"destroy\", this).call(this);\n    }\n    /**\n     * Helper function for `toPhysicalRowPosition` and `toPhysicalColumnPosition`.\n     *\n     * @private\n     * @param {number} visualIndex Visual entry index.\n     * @param {number} physicalIndex Physical entry index.\n     * @param {number} entriesCount Visual entries count.\n     * @param {number} sourceEntriesCount Source entries count.\n     * @param {boolean} contained `true` if it should return only indexes within boundaries of the table (basically\n     * `toPhysical` alias.\n     * @returns {*}\n     */\n\n  }, {\n    key: \"getPhysicalIndexPosition\",\n    value: function getPhysicalIndexPosition(visualIndex, physicalIndex, entriesCount, sourceEntriesCount, contained) {\n      if (!contained) {\n        if (visualIndex >= entriesCount) {\n          return sourceEntriesCount + (visualIndex - entriesCount);\n        }\n      }\n\n      return physicalIndex;\n    }\n    /**\n     * Returns the physical row index. The difference between this and Core's `toPhysical` is that it doesn't return\n     * `null` on rows with indexes higher than the number of rows.\n     *\n     * @private\n     * @param {number} row Visual row index.\n     * @param {boolean} [contained] `true` if it should return only indexes within boundaries of the table (basically\n     * `toPhysical` alias.\n     * @returns {number} The physical row index.\n     */\n\n  }, {\n    key: \"toPhysicalRowPosition\",\n    value: function toPhysicalRowPosition(row) {\n      var contained = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return this.getPhysicalIndexPosition(row, this.hot.toPhysicalRow(row), this.hot.countRows(), this.hot.countSourceRows(), contained);\n    }\n    /**\n     * Returns the physical column index. The difference between this and Core's `toPhysical` is that it doesn't return\n     * `null` on columns with indexes higher than the number of columns.\n     *\n     * @private\n     * @param {number} column Visual column index.\n     * @param {boolean} [contained] `true` if it should return only indexes within boundaries of the table (basically\n     * `toPhysical` alias.\n     * @returns {number} The physical column index.\n     */\n\n  }, {\n    key: \"toPhysicalColumnPosition\",\n    value: function toPhysicalColumnPosition(column) {\n      var contained = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return this.getPhysicalIndexPosition(column, this.hot.toPhysicalColumn(column), this.hot.countCols(), this.hot.countSourceCols(), contained);\n    }\n    /**\n     * Add a sheet to the shared HyperFormula instance.\n     *\n     * @param {string|null} [sheetName] The new sheet name. If not provided (or a null is passed), will be\n     * auto-generated by HyperFormula.\n     * @param {Array} [sheetData] Data passed to the shared HyperFormula instance. Has to be declared as an array of\n     * arrays - array of objects is not supported in this scenario.\n     * @returns {boolean|string} `false` if the data format is unusable or it is impossible to add a new sheet to the\n     * engine, the created sheet name otherwise.\n     */\n\n  }, {\n    key: \"addSheet\",\n    value: function addSheet(sheetName, sheetData) {\n      if (isDefined(sheetData) && !isArrayOfArrays(sheetData)) {\n        warn('The provided data should be an array of arrays.');\n        return false;\n      }\n\n      if (sheetName !== void 0 && sheetName !== null && this.engine.doesSheetExist(sheetName)) {\n        warn('Sheet with the provided name already exists.');\n        return false;\n      }\n\n      try {\n        var actualSheetName = this.engine.addSheet(sheetName !== null && sheetName !== void 0 ? sheetName : void 0);\n\n        if (sheetData) {\n          this.engine.setSheetContent(this.engine.getSheetId(actualSheetName), sheetData);\n        }\n\n        return actualSheetName;\n      } catch (e) {\n        warn(e.message);\n        return false;\n      }\n    }\n    /**\n     * Switch the sheet used as data in the Handsontable instance (it loads the data from the shared HyperFormula\n     * instance).\n     *\n     * @param {string} sheetName Sheet name used in the shared HyperFormula instance.\n     */\n\n  }, {\n    key: \"switchSheet\",\n    value: function switchSheet(sheetName) {\n      if (!this.engine.doesSheetExist(sheetName)) {\n        error(\"The sheet named `\".concat(sheetName, \"` does not exist, switch aborted.\"));\n        return;\n      }\n\n      this.sheetName = sheetName;\n      var serialized = this.engine.getSheetSerialized(this.sheetId);\n\n      if (serialized.length > 0) {\n        this.hot.loadData(serialized, \"\".concat(toUpperCaseFirst(PLUGIN_KEY), \".switchSheet\"));\n      }\n    }\n    /**\n     * Get the cell type under specified visual coordinates.\n     *\n     * @param {number} row Visual row index.\n     * @param {number} column Visual column index.\n     * @param {number} [sheet] The target sheet id, defaults to the current sheet.\n     * @returns {string} Possible values: 'FORMULA' | 'VALUE' | 'ARRAYFORMULA' | 'EMPTY'.\n     */\n\n  }, {\n    key: \"getCellType\",\n    value: function getCellType(row, column) {\n      var sheet = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.sheetId;\n      var physicalRow = this.hot.toPhysicalRow(row);\n      var physicalColumn = this.hot.toPhysicalColumn(column);\n\n      if (physicalRow !== null && physicalColumn !== null) {\n        return this.engine.getCellType({\n          sheet: sheet,\n          row: physicalRow,\n          col: physicalColumn\n        });\n      } else {\n        // Should return `EMPTY` when out of bounds (according to the test cases).\n        return 'EMPTY';\n      }\n    }\n    /**\n     * Returns `true` if under specified visual coordinates is formula.\n     *\n     * @param {number} row Visual row index.\n     * @param {number} column Visual column index.\n     * @param {number} [sheet] The target sheet id, defaults to the current sheet.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isFormulaCellType\",\n    value: function isFormulaCellType(row, column) {\n      var sheet = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.sheetId;\n      var physicalRow = this.hot.toPhysicalRow(row);\n      var physicalColumn = this.hot.toPhysicalColumn(column);\n\n      if (physicalRow === null || physicalColumn === null) {\n        return false;\n      }\n\n      return this.engine.doesCellHaveFormula({\n        sheet: sheet,\n        row: physicalRow,\n        col: physicalColumn\n      });\n    }\n    /**\n     * Renders dependent sheets (handsontable instances) based on the changes - list of the\n     * recalculated dependent cells.\n     *\n     * @private\n     * @param {object[]} dependentCells The values and location of applied changes within HF engine.\n     * @param {boolean} [renderSelf] `true` if it's supposed to render itself, `false` otherwise.\n     */\n\n  }, {\n    key: \"renderDependentSheets\",\n    value: function renderDependentSheets(dependentCells) {\n      var _this11 = this;\n\n      var renderSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var affectedSheetIds = new Set();\n      dependentCells.forEach(function (change) {\n        var _change$address; // For the Named expression the address is empty, hence the `sheetId` is undefined.\n\n\n        var sheetId = change === null || change === void 0 ? void 0 : (_change$address = change.address) === null || _change$address === void 0 ? void 0 : _change$address.sheet;\n\n        if (sheetId !== void 0) {\n          if (!affectedSheetIds.has(sheetId)) {\n            affectedSheetIds.add(sheetId);\n          }\n        }\n      });\n      getRegisteredHotInstances(this.engine).forEach(function (relatedHot, sheetId) {\n        if ((renderSelf || sheetId !== _this11.sheetId) && affectedSheetIds.has(sheetId)) {\n          var _relatedHot$view;\n\n          relatedHot.render();\n          (_relatedHot$view = relatedHot.view) === null || _relatedHot$view === void 0 ? void 0 : _relatedHot$view.adjustElementsSize();\n        }\n      });\n    }\n    /**\n     * Validates dependent cells based on the cells that are modified by the change.\n     *\n     * @private\n     * @param {object[]} dependentCells The values and location of applied changes within HF engine.\n     * @param {object[]} [changedCells] The values and location of applied changes by developer (through API or UI).\n     */\n\n  }, {\n    key: \"validateDependentCells\",\n    value: function validateDependentCells(dependentCells) {\n      var _this12 = this;\n\n      var changedCells = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n      var stringifyAddress = function stringifyAddress(change) {\n        var _change$address2;\n\n        var _ref7 = (_change$address2 = change === null || change === void 0 ? void 0 : change.address) !== null && _change$address2 !== void 0 ? _change$address2 : {},\n            row = _ref7.row,\n            col = _ref7.col,\n            sheet = _ref7.sheet;\n\n        return isDefined(sheet) ? \"\".concat(sheet, \":\").concat(row, \"x\").concat(col) : '';\n      };\n\n      var changedCellsSet = new Set(changedCells.map(function (change) {\n        return stringifyAddress(change);\n      }));\n      dependentCells.forEach(function (change) {\n        var _change$address3, _change$address4;\n\n        var _ref8 = (_change$address3 = change.address) !== null && _change$address3 !== void 0 ? _change$address3 : {},\n            row = _ref8.row,\n            col = _ref8.col;\n\n        var visualRow = isDefined(row) ? _this12.hot.toVisualRow(row) : null;\n        var visualColumn = isDefined(col) ? _this12.hot.toVisualColumn(col) : null; // Don't try to validate cells outside of the visual part of the table.\n\n        if (visualRow === null || visualColumn === null) {\n          return;\n        } // For the Named expression the address is empty, hence the `sheetId` is undefined.\n\n\n        var sheetId = change === null || change === void 0 ? void 0 : (_change$address4 = change.address) === null || _change$address4 === void 0 ? void 0 : _change$address4.sheet;\n        var addressId = stringifyAddress(change); // Validate the cells that depend on the calculated formulas. Skip that cells\n        // where the user directly changes the values - the Core triggers those validators.\n\n        if (sheetId !== void 0 && !changedCellsSet.has(addressId)) {\n          var boundHot = getRegisteredHotInstances(_this12.engine).get(sheetId); // if `sheetId` is not bound to any Handsontable instance, skip the validation process\n\n          if (!boundHot) {\n            return;\n          } // It will just re-render certain cell when necessary.\n\n\n          boundHot.validateCell(boundHot.getDataAtCell(visualRow, visualColumn), boundHot.getCellMeta(visualRow, visualColumn), function () {});\n        }\n      });\n    }\n    /**\n     * Sync a change from the change-related hooks with the engine.\n     *\n     * @private\n     * @param {number} row Visual row index.\n     * @param {number} column Visual column index.\n     * @param {Handsontable.CellValue} newValue New value.\n     * @returns {Array} Array of changes exported from the engine.\n     */\n\n  }, {\n    key: \"syncChangeWithEngine\",\n    value: function syncChangeWithEngine(row, column, newValue) {\n      var address = {\n        row: this.toPhysicalRowPosition(row),\n        col: this.toPhysicalColumnPosition(column),\n        sheet: this.sheetId\n      };\n\n      if (!this.engine.isItPossibleToSetCellContents(address)) {\n        warn(\"Not possible to set cell data at \".concat(JSON.stringify(address)));\n        return;\n      }\n\n      return this.engine.setCellContents(address, newValue);\n    }\n    /**\n     * The hook allows to translate the formula value to calculated value before it goes to the\n     * validator function.\n     *\n     * @private\n     * @param {*} value The cell value to validate.\n     * @param {number} visualRow The visual row index.\n     * @param {number|string} prop The visual column index or property name of the column.\n     * @returns {*} Returns value to validate.\n     */\n\n  }, {\n    key: \"onBeforeValidate\",\n    value: function onBeforeValidate(value, visualRow, prop) {\n      var visualColumn = this.hot.propToCol(prop);\n\n      if (this.isFormulaCellType(visualRow, visualColumn)) {\n        var address = {\n          row: this.hot.toPhysicalRow(visualRow),\n          col: this.hot.toPhysicalColumn(visualColumn),\n          sheet: this.sheetId\n        };\n        var cellValue = this.engine.getCellValue(address); // If `cellValue` is an object it is expected to be an error\n\n        return _typeof(cellValue) === 'object' && cellValue !== null ? cellValue.value : cellValue;\n      }\n\n      return value;\n    }\n    /**\n     * `onBeforeAutofill` hook callback.\n     *\n     * @private\n     * @param {Array[]} fillData The data that was used to fill the `targetRange`. If `beforeAutofill` was used\n     * and returned `[[]]`, this will be the same object that was returned from `beforeAutofill`.\n     * @param {CellRange} sourceRange The range values will be filled from.\n     * @param {CellRange} targetRange The range new values will be filled into.\n     * @returns {boolean|*}\n     */\n\n  }, {\n    key: \"onBeforeAutofill\",\n    value: function onBeforeAutofill(fillData, sourceRange, targetRange) {\n      var _this13 = this;\n\n      var withSheetId = function withSheetId(range) {\n        return _objectSpread(_objectSpread({}, range), {}, {\n          sheet: _this13.sheetId\n        });\n      };\n\n      var engineSourceRange = {\n        start: withSheetId(sourceRange.getTopStartCorner()),\n        end: withSheetId(sourceRange.getBottomEndCorner())\n      };\n      var engineTargetRange = {\n        start: withSheetId(targetRange.getTopStartCorner()),\n        end: withSheetId(targetRange.getBottomEndCorner())\n      }; // Blocks the autofill operation if HyperFormula says that at least one of\n      // the underlying cell's contents cannot be set.\n\n      if (this.engine.isItPossibleToSetCellContents(engineTargetRange) === false) {\n        return false;\n      }\n\n      return this.engine.getFillRangeData(engineSourceRange, engineTargetRange);\n    }\n    /**\n     * `beforeLoadData` hook callback.\n     *\n     * @param {Array} sourceData Array of arrays or array of objects containing data.\n     * @param {boolean} initialLoad Flag that determines whether the data has been loaded during the initialization.\n     * @param {string} [source] Source of the call.\n     * @private\n     */\n\n  }, {\n    key: \"onBeforeLoadData\",\n    value: function onBeforeLoadData(sourceData, initialLoad) {\n      var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n\n      if (source.includes(toUpperCaseFirst(PLUGIN_KEY))) {\n        return;\n      } // This flag needs to be defined, because not passing data to HOT results in HOT auto-generating a `null`-filled\n      // initial dataset.\n\n\n      _classPrivateFieldSet(this, _hotWasInitializedWithEmptyData, isUndefined(this.hot.getSettings().data));\n    }\n    /**\n     * `afterLoadData` hook callback.\n     *\n     * @param {Array} sourceData Array of arrays or array of objects containing data.\n     * @param {boolean} initialLoad Flag that determines whether the data has been loaded during the initialization.\n     * @param {string} [source] Source of the call.\n     * @private\n     */\n\n  }, {\n    key: \"onAfterLoadData\",\n    value: function onAfterLoadData(sourceData, initialLoad) {\n      var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n\n      if (source.includes(toUpperCaseFirst(PLUGIN_KEY))) {\n        return;\n      }\n\n      this.sheetName = setupSheet(this.engine, this.hot.getSettings()[PLUGIN_KEY].sheetName);\n\n      if (!_classPrivateFieldGet(this, _hotWasInitializedWithEmptyData)) {\n        var sourceDataArray = this.hot.getSourceDataArray();\n\n        if (this.engine.isItPossibleToReplaceSheetContent(this.sheetId, sourceDataArray)) {\n          _classPrivateFieldSet(this, _internalOperationPending, true);\n\n          var dependentCells = this.engine.setSheetContent(this.sheetId, this.hot.getSourceDataArray());\n          this.renderDependentSheets(dependentCells);\n\n          _classPrivateFieldSet(this, _internalOperationPending, false);\n        }\n      } else {\n        this.switchSheet(this.sheetName);\n      }\n    }\n    /**\n     * `modifyData` hook callback.\n     *\n     * @private\n     * @param {number} row Physical row height.\n     * @param {number} column Physical column index.\n     * @param {object} valueHolder Object which contains original value which can be modified by overwriting `.value`\n     *   property.\n     * @param {string} ioMode String which indicates for what operation hook is fired (`get` or `set`).\n     */\n\n  }, {\n    key: \"onModifyData\",\n    value: function onModifyData(row, column, valueHolder, ioMode) {\n      if (ioMode !== 'get' || _classPrivateFieldGet(this, _internalOperationPending) || this.sheetName === null || !this.engine.doesSheetExist(this.sheetName)) {\n        return;\n      }\n\n      var visualRow = this.hot.toVisualRow(row); // `column` is here as visual index because of inconsistencies related to hook execution in `src/dataMap`.\n\n      var isFormulaCellType = this.isFormulaCellType(visualRow, column);\n\n      if (!isFormulaCellType) {\n        var cellType = this.getCellType(visualRow, column);\n\n        if (cellType !== 'ARRAY') {\n          if (isEscapedFormulaExpression(valueHolder.value)) {\n            valueHolder.value = unescapeFormulaExpression(valueHolder.value);\n          }\n\n          return;\n        }\n      } // `toPhysicalColumn` is here because of inconsistencies related to hook execution in `DataMap`.\n\n\n      var address = {\n        row: row,\n        col: this.toPhysicalColumnPosition(column),\n        sheet: this.sheetId\n      };\n      var cellValue = this.engine.getCellValue(address); // If `cellValue` is an object it is expected to be an error\n\n      var value = _typeof(cellValue) === 'object' && cellValue !== null ? cellValue.value : cellValue;\n      valueHolder.value = value;\n    }\n    /**\n     * `modifySourceData` hook callback.\n     *\n     * @private\n     * @param {number} row Physical row index.\n     * @param {number|string} columnOrProp Physical column index or prop.\n     * @param {object} valueHolder Object which contains original value which can be modified by overwriting `.value`\n     *   property.\n     * @param {string} ioMode String which indicates for what operation hook is fired (`get` or `set`).\n     */\n\n  }, {\n    key: \"onModifySourceData\",\n    value: function onModifySourceData(row, columnOrProp, valueHolder, ioMode) {\n      if (ioMode !== 'get' || _classPrivateFieldGet(this, _internalOperationPending) || this.sheetName === null || !this.engine.doesSheetExist(this.sheetName)) {\n        return;\n      }\n\n      var visualRow = this.hot.toVisualRow(row);\n      var visualColumn = this.hot.propToCol(columnOrProp); // `column` is here as visual index because of inconsistencies related to hook execution in `src/dataMap`.\n\n      var isFormulaCellType = this.isFormulaCellType(visualRow, visualColumn);\n\n      if (!isFormulaCellType) {\n        var cellType = this.getCellType(visualRow, visualColumn);\n\n        if (cellType !== 'ARRAY') {\n          return;\n        }\n      }\n\n      var dimensions = this.engine.getSheetDimensions(this.engine.getSheetId(this.sheetName)); // Don't actually change the source data if HyperFormula is not\n      // initialized yet. This is done to allow the `afterLoadData` hook to\n      // load the existing source data with `Handsontable#getSourceDataArray`\n      // properly.\n\n      if (dimensions.width === 0 && dimensions.height === 0) {\n        return;\n      }\n\n      var address = {\n        row: row,\n        // Workaround for inconsistencies in `src/dataSource.js`\n        col: this.toPhysicalColumnPosition(visualColumn),\n        sheet: this.sheetId\n      };\n      valueHolder.value = this.engine.getCellSerialized(address);\n    }\n    /**\n     * `onAfterSetDataAtCell` hook callback.\n     *\n     * @private\n     * @param {Array[]} changes An array of changes in format [[row, prop, oldValue, value], ...].\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link http://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).\n     */\n\n  }, {\n    key: \"onAfterSetDataAtCell\",\n    value: function onAfterSetDataAtCell(changes, source) {\n      var _this14 = this;\n\n      if (isBlockedSource(source)) {\n        return;\n      }\n\n      var outOfBoundsChanges = [];\n      var changedCells = [];\n      var dependentCells = this.engine.batch(function () {\n        changes.forEach(function (_ref9) {\n          var _ref10 = _slicedToArray(_ref9, 4),\n              row = _ref10[0],\n              prop = _ref10[1],\n              newValue = _ref10[3];\n\n          var column = _this14.hot.propToCol(prop);\n\n          var physicalRow = _this14.hot.toPhysicalRow(row);\n\n          var physicalColumn = _this14.hot.toPhysicalColumn(column);\n\n          var address = {\n            row: physicalRow,\n            col: physicalColumn,\n            sheet: _this14.sheetId\n          };\n\n          if (physicalRow !== null && physicalColumn !== null) {\n            _this14.syncChangeWithEngine(row, column, newValue);\n          } else {\n            outOfBoundsChanges.push([row, column, newValue]);\n          }\n\n          changedCells.push({\n            address: address\n          });\n        });\n      });\n\n      if (outOfBoundsChanges.length) {\n        // Workaround for rows/columns being created two times (by HOT and the engine).\n        // (unfortunately, this requires an extra re-render)\n        this.hot.addHookOnce('afterChange', function () {\n          var outOfBoundsDependentCells = _this14.engine.batch(function () {\n            outOfBoundsChanges.forEach(function (_ref11) {\n              var _ref12 = _slicedToArray(_ref11, 3),\n                  row = _ref12[0],\n                  column = _ref12[1],\n                  newValue = _ref12[2];\n\n              _this14.syncChangeWithEngine(row, column, newValue);\n            });\n          });\n\n          _this14.renderDependentSheets(outOfBoundsDependentCells, true);\n        });\n      }\n\n      this.renderDependentSheets(dependentCells);\n      this.validateDependentCells(dependentCells, changedCells);\n    }\n    /**\n     * `onAfterSetSourceDataAtCell` hook callback.\n     *\n     * @private\n     * @param {Array[]} changes An array of changes in format [[row, column, oldValue, value], ...].\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link http://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).\n     */\n\n  }, {\n    key: \"onAfterSetSourceDataAtCell\",\n    value: function onAfterSetSourceDataAtCell(changes, source) {\n      var _this15 = this;\n\n      if (isBlockedSource(source)) {\n        return;\n      }\n\n      var dependentCells = [];\n      var changedCells = [];\n      changes.forEach(function (_ref13) {\n        var _ref14 = _slicedToArray(_ref13, 4),\n            row = _ref14[0],\n            prop = _ref14[1],\n            newValue = _ref14[3];\n\n        var column = _this15.hot.propToCol(prop);\n\n        if (!isNumeric(column)) {\n          return;\n        }\n\n        var address = {\n          row: row,\n          col: _this15.toPhysicalColumnPosition(column),\n          sheet: _this15.sheetId\n        };\n\n        if (!_this15.engine.isItPossibleToSetCellContents(address)) {\n          warn(\"Not possible to set source cell data at \".concat(JSON.stringify(address)));\n          return;\n        }\n\n        changedCells.push({\n          address: address\n        });\n        dependentCells.push.apply(dependentCells, _toConsumableArray(_this15.engine.setCellContents(address, newValue)));\n      });\n      this.renderDependentSheets(dependentCells);\n      this.validateDependentCells(dependentCells, changedCells);\n    }\n    /**\n     * `beforeCreateRow` hook callback.\n     *\n     * @private\n     * @param {number} row Represents the visual index of first newly created row in the data source array.\n     * @param {number} amount Number of newly created rows in the data source array.\n     * @returns {*|boolean} If false is returned the action is canceled.\n     */\n\n  }, {\n    key: \"onBeforeCreateRow\",\n    value: function onBeforeCreateRow(row, amount) {\n      if (this.sheetId === null || !this.engine.doesSheetExist(this.sheetName) || !this.engine.isItPossibleToAddRows(this.sheetId, [this.toPhysicalRowPosition(row), amount])) {\n        return false;\n      }\n    }\n    /**\n     * `beforeCreateCol` hook callback.\n     *\n     * @private\n     * @param {number} col Represents the visual index of first newly created column in the data source.\n     * @param {number} amount Number of newly created columns in the data source.\n     * @returns {*|boolean} If false is returned the action is canceled.\n     */\n\n  }, {\n    key: \"onBeforeCreateCol\",\n    value: function onBeforeCreateCol(col, amount) {\n      if (this.sheetId === null || !this.engine.doesSheetExist(this.sheetName) || !this.engine.isItPossibleToAddColumns(this.sheetId, [this.toPhysicalColumnPosition(col), amount])) {\n        return false;\n      }\n    }\n    /**\n     * `beforeRemoveRow` hook callback.\n     *\n     * @private\n     * @param {number} row Visual index of starter row.\n     * @param {number} amount Amount of rows to be removed.\n     * @param {number[]} physicalRows An array of physical rows removed from the data source.\n     * @returns {*|boolean} If false is returned the action is canceled.\n     */\n\n  }, {\n    key: \"onBeforeRemoveRow\",\n    value: function onBeforeRemoveRow(row, amount, physicalRows) {\n      var _this16 = this;\n\n      var possible = physicalRows.every(function (physicalRow) {\n        return _this16.engine.isItPossibleToRemoveRows(_this16.sheetId, [physicalRow, 1]);\n      });\n      return possible === false ? false : void 0;\n    }\n    /**\n     * `beforeRemoveCol` hook callback.\n     *\n     * @private\n     * @param {number} col Visual index of starter column.\n     * @param {number} amount Amount of columns to be removed.\n     * @param {number[]} physicalColumns An array of physical columns removed from the data source.\n     * @returns {*|boolean} If false is returned the action is canceled.\n     */\n\n  }, {\n    key: \"onBeforeRemoveCol\",\n    value: function onBeforeRemoveCol(col, amount, physicalColumns) {\n      var _this17 = this;\n\n      var possible = physicalColumns.every(function (physicalColumn) {\n        return _this17.engine.isItPossibleToRemoveColumns(_this17.sheetId, [physicalColumn, 1]);\n      });\n      return possible === false ? false : void 0;\n    }\n    /**\n     * `afterCreateRow` hook callback.\n     *\n     * @private\n     * @param {number} row Represents the visual index of first newly created row in the data source array.\n     * @param {number} amount Number of newly created rows in the data source array.\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link http://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).\n     */\n\n  }, {\n    key: \"onAfterCreateRow\",\n    value: function onAfterCreateRow(row, amount, source) {\n      if (isBlockedSource(source)) {\n        return;\n      }\n\n      var changes = this.engine.addRows(this.sheetId, [this.toPhysicalRowPosition(row), amount]);\n      this.renderDependentSheets(changes);\n    }\n    /**\n     * `afterCreateCol` hook callback.\n     *\n     * @private\n     * @param {number} col Represents the visual index of first newly created column in the data source.\n     * @param {number} amount Number of newly created columns in the data source.\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link http://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).\n     */\n\n  }, {\n    key: \"onAfterCreateCol\",\n    value: function onAfterCreateCol(col, amount, source) {\n      if (isBlockedSource(source)) {\n        return;\n      }\n\n      var changes = this.engine.addColumns(this.sheetId, [this.toPhysicalColumnPosition(col), amount]);\n      this.renderDependentSheets(changes);\n    }\n    /**\n     * `afterRemoveRow` hook callback.\n     *\n     * @private\n     * @param {number} row Visual index of starter row.\n     * @param {number} amount An amount of removed rows.\n     * @param {number[]} physicalRows An array of physical rows removed from the data source.\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link http://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).\n     */\n\n  }, {\n    key: \"onAfterRemoveRow\",\n    value: function onAfterRemoveRow(row, amount, physicalRows, source) {\n      var _this18 = this;\n\n      if (isBlockedSource(source)) {\n        return;\n      }\n\n      var descendingPhysicalRows = physicalRows.sort().reverse();\n      var changes = this.engine.batch(function () {\n        descendingPhysicalRows.forEach(function (physicalRow) {\n          _this18.engine.removeRows(_this18.sheetId, [physicalRow, 1]);\n        });\n      });\n      this.renderDependentSheets(changes);\n    }\n    /**\n     * `afterRemoveCol` hook callback.\n     *\n     * @private\n     * @param {number} col Visual index of starter column.\n     * @param {number} amount An amount of removed columns.\n     * @param {number[]} physicalColumns An array of physical columns removed from the data source.\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link http://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).\n     */\n\n  }, {\n    key: \"onAfterRemoveCol\",\n    value: function onAfterRemoveCol(col, amount, physicalColumns, source) {\n      var _this19 = this;\n\n      if (isBlockedSource(source)) {\n        return;\n      }\n\n      var descendingPhysicalColumns = physicalColumns.sort().reverse();\n      var changes = this.engine.batch(function () {\n        descendingPhysicalColumns.forEach(function (physicalColumn) {\n          _this19.engine.removeColumns(_this19.sheetId, [physicalColumn, 1]);\n        });\n      });\n      this.renderDependentSheets(changes);\n    }\n    /**\n     * `afterDetachChild` hook callback.\n     * Used to sync the data of the rows detached in the Nested Rows plugin with the engine's dataset.\n     *\n     * @private\n     * @param {object} parent An object representing the parent from which the element was detached.\n     * @param {object} element The detached element.\n     * @param {number} finalElementRowIndex The final row index of the detached element.\n     */\n\n  }, {\n    key: \"onAfterDetachChild\",\n    value: function onAfterDetachChild(parent, element, finalElementRowIndex) {\n      var _element$__children,\n          _this20 = this;\n\n      _classPrivateFieldSet(this, _internalOperationPending, true);\n\n      var rowsData = this.hot.getSourceDataArray(finalElementRowIndex, 0, finalElementRowIndex + (((_element$__children = element.__children) === null || _element$__children === void 0 ? void 0 : _element$__children.length) || 0), this.hot.countSourceCols());\n\n      _classPrivateFieldSet(this, _internalOperationPending, false);\n\n      rowsData.forEach(function (row, relativeRowIndex) {\n        row.forEach(function (value, colIndex) {\n          _this20.engine.setCellContents({\n            col: colIndex,\n            row: finalElementRowIndex + relativeRowIndex,\n            sheet: _this20.sheetId\n          }, [[value]]);\n        });\n      });\n    }\n    /**\n     * Called when a value is updated in the engine.\n     *\n     * @private\n     * @fires Hooks#afterFormulasValuesUpdate\n     * @param {Array} changes The values and location of applied changes.\n     */\n\n  }, {\n    key: \"onEngineValuesUpdated\",\n    value: function onEngineValuesUpdated(changes) {\n      this.hot.runHooks('afterFormulasValuesUpdate', changes);\n    }\n    /**\n     * Called when a named expression is added to the engine instance.\n     *\n     * @private\n     * @fires Hooks#afterNamedExpressionAdded\n     * @param {string} namedExpressionName The name of the added expression.\n     * @param {Array} changes The values and location of applied changes.\n     */\n\n  }, {\n    key: \"onEngineNamedExpressionsAdded\",\n    value: function onEngineNamedExpressionsAdded(namedExpressionName, changes) {\n      this.hot.runHooks('afterNamedExpressionAdded', namedExpressionName, changes);\n    }\n    /**\n     * Called when a named expression is removed from the engine instance.\n     *\n     * @private\n     * @fires Hooks#afterNamedExpressionRemoved\n     * @param {string} namedExpressionName The name of the removed expression.\n     * @param {Array} changes The values and location of applied changes.\n     */\n\n  }, {\n    key: \"onEngineNamedExpressionsRemoved\",\n    value: function onEngineNamedExpressionsRemoved(namedExpressionName, changes) {\n      this.hot.runHooks('afterNamedExpressionRemoved', namedExpressionName, changes);\n    }\n    /**\n     * Called when a new sheet is added to the engine instance.\n     *\n     * @private\n     * @fires Hooks#afterSheetAdded\n     * @param {string} addedSheetDisplayName The name of the added sheet.\n     */\n\n  }, {\n    key: \"onEngineSheetAdded\",\n    value: function onEngineSheetAdded(addedSheetDisplayName) {\n      this.hot.runHooks('afterSheetAdded', addedSheetDisplayName);\n    }\n    /**\n     * Called when a sheet in the engine instance is renamed.\n     *\n     * @private\n     * @fires Hooks#afterSheetRenamed\n     * @param {string} oldDisplayName The old name of the sheet.\n     * @param {string} newDisplayName The new name of the sheet.\n     */\n\n  }, {\n    key: \"onEngineSheetRenamed\",\n    value: function onEngineSheetRenamed(oldDisplayName, newDisplayName) {\n      this.hot.runHooks('afterSheetRenamed', oldDisplayName, newDisplayName);\n    }\n    /**\n     * Called when a sheet is removed from the engine instance.\n     *\n     * @private\n     * @fires Hooks#afterSheetRemoved\n     * @param {string} removedSheetDisplayName The removed sheet name.\n     * @param {Array} changes The values and location of applied changes.\n     */\n\n  }, {\n    key: \"onEngineSheetRemoved\",\n    value: function onEngineSheetRemoved(removedSheetDisplayName, changes) {\n      this.hot.runHooks('afterSheetRemoved', removedSheetDisplayName, changes);\n    }\n  }], [{\n    key: \"PLUGIN_KEY\",\n    get: function get() {\n      return PLUGIN_KEY;\n    }\n  }, {\n    key: \"PLUGIN_PRIORITY\",\n    get: function get() {\n      return PLUGIN_PRIORITY;\n    }\n    /**\n     * Flag used to bypass hooks in internal operations.\n     *\n     * @private\n     * @type {boolean}\n     */\n\n  }]);\n\n  return Formulas;\n}(BasePlugin);","map":{"version":3,"names":["_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","TypeError","iter","Symbol","iterator","Array","from","isArray","_arrayLikeToArray","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","_typeof","obj","constructor","prototype","_slicedToArray","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","o","minLen","n","toString","call","slice","name","test","len","arr2","_i","_arr","_n","_d","_s","_e","next","done","value","err","_classCallCheck","instance","Constructor","_defineProperties","props","descriptor","configurable","writable","_createClass","protoProps","staticProps","_get","Reflect","get","bind","property","receiver","base","_superPropBase","desc","hasOwnProperty","_getPrototypeOf","_inherits","subClass","superClass","create","_setPrototypeOf","p","setPrototypeOf","__proto__","_createSuper","Derived","hasNativeReflectConstruct","_isNativeReflectConstruct","_createSuperInternal","Super","result","NewTarget","construct","_possibleConstructorReturn","self","_assertThisInitialized","ReferenceError","sham","Proxy","Boolean","valueOf","e","getPrototypeOf","_classPrivateFieldInitSpec","privateMap","_checkPrivateRedeclaration","set","privateCollection","has","_classPrivateFieldSet","_classExtractFieldDescriptor","_classApplyDescriptorSet","_classPrivateFieldGet","_classApplyDescriptorGet","action","BasePlugin","staticRegister","error","warn","isNumeric","isDefined","isUndefined","setupEngine","setupSheet","unregisterEngine","getRegisteredHotInstances","isEscapedFormulaExpression","unescapeFormulaExpression","getEngineSettingsWithOverrides","isArrayOfArrays","toUpperCaseFirst","Hooks","PLUGIN_KEY","PLUGIN_PRIORITY","ROW_MOVE_UNDO_REDO_NAME","getSingleton","register","isBlockedSource","_internalOperationPending","WeakMap","_hotWasInitializedWithEmptyData","_engineListeners","Formulas","_BasePlugin","_super","_this","_len","_args","_key","concat","_this2","onEngineValuesUpdated","_this3","onEngineNamedExpressionsAdded","_this4","onEngineNamedExpressionsRemoved","_this5","onEngineSheetAdded","_this6","onEngineSheetRenamed","_this7","onEngineSheetRemoved","sheetName","engine","getSheetId","isEnabled","hot","getSettings","enablePlugin","_setupEngine","_this8","enabled","doesSheetExist","newSheetName","addSheet","getSourceDataArray","addHook","onBeforeLoadData","onAfterLoadData","onModifyData","onModifySourceData","onBeforeValidate","onAfterSetSourceDataAtCell","onAfterSetDataAtCell","onBeforeCreateRow","onBeforeCreateCol","onAfterCreateRow","onAfterCreateCol","onBeforeRemoveRow","onBeforeRemoveCol","onAfterRemoveRow","onAfterRemoveCol","actionType","undo","redo","onAfterDetachChild","onBeforeAutofill","_ref","_ref2","eventName","listener","on","disablePlugin","_this9","_ref3","_ref4","off","updatePlugin","newSettings","updateConfig","pluginSettings","switchSheet","data","destroy","_this10","_ref5","_this10$engine","_ref6","getPhysicalIndexPosition","visualIndex","physicalIndex","entriesCount","sourceEntriesCount","contained","toPhysicalRowPosition","row","undefined","toPhysicalRow","countRows","countSourceRows","toPhysicalColumnPosition","column","toPhysicalColumn","countCols","countSourceCols","sheetData","actualSheetName","setSheetContent","message","serialized","getSheetSerialized","sheetId","loadData","getCellType","sheet","physicalRow","physicalColumn","col","isFormulaCellType","doesCellHaveFormula","renderDependentSheets","dependentCells","_this11","renderSelf","affectedSheetIds","Set","change","_change$address","address","add","relatedHot","_relatedHot$view","render","view","adjustElementsSize","validateDependentCells","_this12","changedCells","stringifyAddress","_change$address2","_ref7","changedCellsSet","map","_change$address3","_change$address4","_ref8","visualRow","toVisualRow","visualColumn","toVisualColumn","addressId","boundHot","validateCell","getDataAtCell","getCellMeta","syncChangeWithEngine","newValue","isItPossibleToSetCellContents","JSON","stringify","setCellContents","prop","propToCol","cellValue","getCellValue","fillData","sourceRange","targetRange","_this13","withSheetId","range","engineSourceRange","start","getTopStartCorner","end","getBottomEndCorner","engineTargetRange","getFillRangeData","sourceData","initialLoad","includes","sourceDataArray","isItPossibleToReplaceSheetContent","valueHolder","ioMode","cellType","columnOrProp","dimensions","getSheetDimensions","width","height","getCellSerialized","changes","_this14","outOfBoundsChanges","batch","_ref9","_ref10","addHookOnce","outOfBoundsDependentCells","_ref11","_ref12","_this15","_ref13","_ref14","amount","isItPossibleToAddRows","isItPossibleToAddColumns","physicalRows","_this16","possible","every","isItPossibleToRemoveRows","physicalColumns","_this17","isItPossibleToRemoveColumns","addRows","addColumns","_this18","descendingPhysicalRows","sort","reverse","removeRows","_this19","descendingPhysicalColumns","removeColumns","parent","element","finalElementRowIndex","_element$__children","_this20","rowsData","__children","relativeRowIndex","colIndex","runHooks","namedExpressionName","addedSheetDisplayName","oldDisplayName","newDisplayName","removedSheetDisplayName"],"sources":["/home/ubuntu/community/vue-web/node_modules/handsontable/plugins/formulas/formulas.mjs"],"sourcesContent":["function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/es.array.reverse.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.weak-map.js\";\nimport \"core-js/modules/es.object.set-prototype-of.js\";\nimport \"core-js/modules/es.object.get-prototype-of.js\";\nimport \"core-js/modules/es.reflect.construct.js\";\nimport \"core-js/modules/es.reflect.get.js\";\nimport \"core-js/modules/es.object.get-own-property-descriptor.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.object.get-own-property-descriptors.js\";\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _get() { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }\nfunction _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); } }\nfunction _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }\nfunction _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } }\nfunction _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\"); return _classApplyDescriptorGet(receiver, descriptor); }\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to \" + action + \" private field on non-instance\"); } return privateMap.get(receiver); }\nfunction _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\nimport { BasePlugin } from \"../base/index.mjs\";\nimport staticRegister from \"../../utils/staticRegister.mjs\";\nimport { error, warn } from \"../../helpers/console.mjs\";\nimport { isNumeric } from \"../../helpers/number.mjs\";\nimport { isDefined, isUndefined } from \"../../helpers/mixed.mjs\";\nimport { setupEngine, setupSheet, unregisterEngine, getRegisteredHotInstances } from \"./engine/register.mjs\";\nimport { isEscapedFormulaExpression, unescapeFormulaExpression } from \"./utils.mjs\";\nimport { getEngineSettingsWithOverrides } from \"./engine/settings.mjs\";\nimport { isArrayOfArrays } from \"../../helpers/data.mjs\";\nimport { toUpperCaseFirst } from \"../../helpers/string.mjs\";\nimport Hooks from \"../../pluginHooks.mjs\";\nexport var PLUGIN_KEY = 'formulas';\nexport var PLUGIN_PRIORITY = 260;\nvar ROW_MOVE_UNDO_REDO_NAME = 'row_move';\nHooks.getSingleton().register('afterNamedExpressionAdded');\nHooks.getSingleton().register('afterNamedExpressionRemoved');\nHooks.getSingleton().register('afterSheetAdded');\nHooks.getSingleton().register('afterSheetRemoved');\nHooks.getSingleton().register('afterSheetRenamed');\nHooks.getSingleton().register('afterFormulasValuesUpdate');\n\n// This function will be used for detecting changes coming from the `UndoRedo` plugin. This kind of change won't be\n// handled by whole body of listeners and therefore won't change undo/redo stack inside engine provided by HyperFormula.\n// HyperFormula's `undo` and `redo` methods will do it instead. Please keep in mind that undo/redo stacks inside\n// instances of Handsontable and HyperFormula should be synced (number of actions should be the same).\nvar isBlockedSource = function isBlockedSource(source) {\n  return source === 'UndoRedo.undo' || source === 'UndoRedo.redo' || source === 'auto';\n};\n\n/**\n * This plugin allows you to perform Excel-like calculations in your business applications. It does it by an\n * integration with our other product, [HyperFormula](https://github.com/handsontable/hyperformula/), which is a\n * powerful calculation engine with an extensive number of features.\n *\n * To test out HyperFormula, see [this guide](@/guides/formulas/formula-calculation.md#available-functions).\n *\n * @plugin Formulas\n * @class Formulas\n */\nvar _internalOperationPending = /*#__PURE__*/new WeakMap();\nvar _hotWasInitializedWithEmptyData = /*#__PURE__*/new WeakMap();\nvar _engineListeners = /*#__PURE__*/new WeakMap();\nexport var Formulas = /*#__PURE__*/function (_BasePlugin) {\n  _inherits(Formulas, _BasePlugin);\n  var _super = _createSuper(Formulas);\n  function Formulas() {\n    var _this;\n    _classCallCheck(this, Formulas);\n    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {\n      _args[_key] = arguments[_key];\n    }\n    _this = _super.call.apply(_super, [this].concat(_args));\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _internalOperationPending, {\n      writable: true,\n      value: false\n    });\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _hotWasInitializedWithEmptyData, {\n      writable: true,\n      value: false\n    });\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _engineListeners, {\n      writable: true,\n      value: [['valuesUpdated', function () {\n        var _this2;\n        return (_this2 = _this).onEngineValuesUpdated.apply(_this2, arguments);\n      }], ['namedExpressionAdded', function () {\n        var _this3;\n        return (_this3 = _this).onEngineNamedExpressionsAdded.apply(_this3, arguments);\n      }], ['namedExpressionRemoved', function () {\n        var _this4;\n        return (_this4 = _this).onEngineNamedExpressionsRemoved.apply(_this4, arguments);\n      }], ['sheetAdded', function () {\n        var _this5;\n        return (_this5 = _this).onEngineSheetAdded.apply(_this5, arguments);\n      }], ['sheetRenamed', function () {\n        var _this6;\n        return (_this6 = _this).onEngineSheetRenamed.apply(_this6, arguments);\n      }], ['sheetRemoved', function () {\n        var _this7;\n        return (_this7 = _this).onEngineSheetRemoved.apply(_this7, arguments);\n      }]]\n    });\n    _defineProperty(_assertThisInitialized(_this), \"staticRegister\", staticRegister('formulas'));\n    _defineProperty(_assertThisInitialized(_this), \"engine\", null);\n    _defineProperty(_assertThisInitialized(_this), \"sheetName\", null);\n    return _this;\n  }\n  _createClass(Formulas, [{\n    key: \"sheetId\",\n    get:\n    /**\n     * HyperFormula's sheet id.\n     *\n     * @type {number|null}\n     */\n    function get() {\n      return this.sheetName === null ? null : this.engine.getSheetId(this.sheetName);\n    }\n\n    /**\n     * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\n     * hook and if it returns `true` then the {@link Formulas#enablePlugin} method is called.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isEnabled\",\n    value: function isEnabled() {\n      /* eslint-disable no-unneeded-ternary */\n      return this.hot.getSettings()[PLUGIN_KEY] ? true : false;\n    }\n\n    /**\n     * Enables the plugin functionality for this Handsontable instance.\n     */\n  }, {\n    key: \"enablePlugin\",\n    value: function enablePlugin() {\n      var _setupEngine,\n        _this8 = this;\n      if (this.enabled) {\n        return;\n      }\n      this.engine = (_setupEngine = setupEngine(this.hot)) !== null && _setupEngine !== void 0 ? _setupEngine : this.engine;\n      if (!this.engine) {\n        warn('Missing the required `engine` key in the Formulas settings. Please fill it with either an' + ' engine class or an engine instance.');\n        return;\n      }\n\n      // Useful for disabling -> enabling the plugin using `updateSettings` or the API.\n      if (this.sheetName !== null && !this.engine.doesSheetExist(this.sheetName)) {\n        var newSheetName = this.addSheet(this.sheetName, this.hot.getSourceDataArray());\n        if (newSheetName !== false) {\n          this.sheetName = newSheetName;\n        }\n      }\n      this.addHook('beforeLoadData', function () {\n        return _this8.onBeforeLoadData.apply(_this8, arguments);\n      });\n      this.addHook('afterLoadData', function () {\n        return _this8.onAfterLoadData.apply(_this8, arguments);\n      });\n      this.addHook('modifyData', function () {\n        return _this8.onModifyData.apply(_this8, arguments);\n      });\n      this.addHook('modifySourceData', function () {\n        return _this8.onModifySourceData.apply(_this8, arguments);\n      });\n      this.addHook('beforeValidate', function () {\n        return _this8.onBeforeValidate.apply(_this8, arguments);\n      });\n      this.addHook('afterSetSourceDataAtCell', function () {\n        return _this8.onAfterSetSourceDataAtCell.apply(_this8, arguments);\n      });\n      this.addHook('afterSetDataAtCell', function () {\n        return _this8.onAfterSetDataAtCell.apply(_this8, arguments);\n      });\n      this.addHook('afterSetDataAtRowProp', function () {\n        return _this8.onAfterSetDataAtCell.apply(_this8, arguments);\n      });\n      this.addHook('beforeCreateRow', function () {\n        return _this8.onBeforeCreateRow.apply(_this8, arguments);\n      });\n      this.addHook('beforeCreateCol', function () {\n        return _this8.onBeforeCreateCol.apply(_this8, arguments);\n      });\n      this.addHook('afterCreateRow', function () {\n        return _this8.onAfterCreateRow.apply(_this8, arguments);\n      });\n      this.addHook('afterCreateCol', function () {\n        return _this8.onAfterCreateCol.apply(_this8, arguments);\n      });\n      this.addHook('beforeRemoveRow', function () {\n        return _this8.onBeforeRemoveRow.apply(_this8, arguments);\n      });\n      this.addHook('beforeRemoveCol', function () {\n        return _this8.onBeforeRemoveCol.apply(_this8, arguments);\n      });\n      this.addHook('afterRemoveRow', function () {\n        return _this8.onAfterRemoveRow.apply(_this8, arguments);\n      });\n      this.addHook('afterRemoveCol', function () {\n        return _this8.onAfterRemoveCol.apply(_this8, arguments);\n      });\n\n      // Handling undo actions on data just using HyperFormula's UndoRedo mechanism\n      this.addHook('beforeUndo', function (action) {\n        // TODO: Move action isn't handled by HyperFormula.\n        if ((action === null || action === void 0 ? void 0 : action.actionType) === ROW_MOVE_UNDO_REDO_NAME) {\n          return;\n        }\n        _this8.engine.undo();\n      });\n\n      // Handling redo actions on data just using HyperFormula's UndoRedo mechanism\n      this.addHook('beforeRedo', function (action) {\n        // TODO: Move action isn't handled by HyperFormula.\n        if ((action === null || action === void 0 ? void 0 : action.actionType) === ROW_MOVE_UNDO_REDO_NAME) {\n          return;\n        }\n        _this8.engine.redo();\n      });\n      this.addHook('afterDetachChild', function () {\n        return _this8.onAfterDetachChild.apply(_this8, arguments);\n      });\n      this.addHook('beforeAutofill', function () {\n        return _this8.onBeforeAutofill.apply(_this8, arguments);\n      });\n      _classPrivateFieldGet(this, _engineListeners).forEach(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n          eventName = _ref2[0],\n          listener = _ref2[1];\n        return _this8.engine.on(eventName, listener);\n      });\n      _get(_getPrototypeOf(Formulas.prototype), \"enablePlugin\", this).call(this);\n    }\n\n    /**\n     * Disables the plugin functionality for this Handsontable instance.\n     */\n  }, {\n    key: \"disablePlugin\",\n    value: function disablePlugin() {\n      var _this9 = this;\n      _classPrivateFieldGet(this, _engineListeners).forEach(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n          eventName = _ref4[0],\n          listener = _ref4[1];\n        return _this9.engine.off(eventName, listener);\n      });\n      unregisterEngine(this.engine, this.hot);\n      this.engine = null;\n      _get(_getPrototypeOf(Formulas.prototype), \"disablePlugin\", this).call(this);\n    }\n\n    /**\n     * Triggered on `updateSettings`.\n     *\n     * @private\n     * @param {object} newSettings New set of settings passed to the `updateSettings` method.\n     */\n  }, {\n    key: \"updatePlugin\",\n    value: function updatePlugin(newSettings) {\n      this.engine.updateConfig(getEngineSettingsWithOverrides(this.hot.getSettings()));\n      var pluginSettings = this.hot.getSettings()[PLUGIN_KEY];\n      if (isDefined(pluginSettings) && isDefined(pluginSettings.sheetName) && pluginSettings.sheetName !== this.sheetName) {\n        this.switchSheet(pluginSettings.sheetName);\n      }\n\n      // If no data was passed to the `updateSettings` method and no sheet is connected to the instance -> create a\n      // new sheet using the currently used data. Otherwise, it will be handled by the `afterLoadData` call.\n      if (!newSettings.data && this.sheetName === null) {\n        var sheetName = this.hot.getSettings()[PLUGIN_KEY].sheetName;\n        if (sheetName && this.engine.doesSheetExist(sheetName)) {\n          this.switchSheet(this.sheetName);\n        } else {\n          this.sheetName = this.addSheet(sheetName !== null && sheetName !== void 0 ? sheetName : void 0, this.hot.getSourceDataArray());\n        }\n      }\n      _get(_getPrototypeOf(Formulas.prototype), \"updatePlugin\", this).call(this, newSettings);\n    }\n\n    /**\n     * Destroys the plugin instance.\n     */\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var _this10 = this;\n      _classPrivateFieldGet(this, _engineListeners).forEach(function (_ref5) {\n        var _this10$engine;\n        var _ref6 = _slicedToArray(_ref5, 2),\n          eventName = _ref6[0],\n          listener = _ref6[1];\n        return (_this10$engine = _this10.engine) === null || _this10$engine === void 0 ? void 0 : _this10$engine.off(eventName, listener);\n      });\n      _classPrivateFieldSet(this, _engineListeners, null);\n      unregisterEngine(this.engine, this.hot);\n      this.engine = null;\n      _get(_getPrototypeOf(Formulas.prototype), \"destroy\", this).call(this);\n    }\n\n    /**\n     * Helper function for `toPhysicalRowPosition` and `toPhysicalColumnPosition`.\n     *\n     * @private\n     * @param {number} visualIndex Visual entry index.\n     * @param {number} physicalIndex Physical entry index.\n     * @param {number} entriesCount Visual entries count.\n     * @param {number} sourceEntriesCount Source entries count.\n     * @param {boolean} contained `true` if it should return only indexes within boundaries of the table (basically\n     * `toPhysical` alias.\n     * @returns {*}\n     */\n  }, {\n    key: \"getPhysicalIndexPosition\",\n    value: function getPhysicalIndexPosition(visualIndex, physicalIndex, entriesCount, sourceEntriesCount, contained) {\n      if (!contained) {\n        if (visualIndex >= entriesCount) {\n          return sourceEntriesCount + (visualIndex - entriesCount);\n        }\n      }\n      return physicalIndex;\n    }\n\n    /**\n     * Returns the physical row index. The difference between this and Core's `toPhysical` is that it doesn't return\n     * `null` on rows with indexes higher than the number of rows.\n     *\n     * @private\n     * @param {number} row Visual row index.\n     * @param {boolean} [contained] `true` if it should return only indexes within boundaries of the table (basically\n     * `toPhysical` alias.\n     * @returns {number} The physical row index.\n     */\n  }, {\n    key: \"toPhysicalRowPosition\",\n    value: function toPhysicalRowPosition(row) {\n      var contained = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return this.getPhysicalIndexPosition(row, this.hot.toPhysicalRow(row), this.hot.countRows(), this.hot.countSourceRows(), contained);\n    }\n\n    /**\n     * Returns the physical column index. The difference between this and Core's `toPhysical` is that it doesn't return\n     * `null` on columns with indexes higher than the number of columns.\n     *\n     * @private\n     * @param {number} column Visual column index.\n     * @param {boolean} [contained] `true` if it should return only indexes within boundaries of the table (basically\n     * `toPhysical` alias.\n     * @returns {number} The physical column index.\n     */\n  }, {\n    key: \"toPhysicalColumnPosition\",\n    value: function toPhysicalColumnPosition(column) {\n      var contained = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return this.getPhysicalIndexPosition(column, this.hot.toPhysicalColumn(column), this.hot.countCols(), this.hot.countSourceCols(), contained);\n    }\n\n    /**\n     * Add a sheet to the shared HyperFormula instance.\n     *\n     * @param {string|null} [sheetName] The new sheet name. If not provided (or a null is passed), will be\n     * auto-generated by HyperFormula.\n     * @param {Array} [sheetData] Data passed to the shared HyperFormula instance. Has to be declared as an array of\n     * arrays - array of objects is not supported in this scenario.\n     * @returns {boolean|string} `false` if the data format is unusable or it is impossible to add a new sheet to the\n     * engine, the created sheet name otherwise.\n     */\n  }, {\n    key: \"addSheet\",\n    value: function addSheet(sheetName, sheetData) {\n      if (isDefined(sheetData) && !isArrayOfArrays(sheetData)) {\n        warn('The provided data should be an array of arrays.');\n        return false;\n      }\n      if (sheetName !== void 0 && sheetName !== null && this.engine.doesSheetExist(sheetName)) {\n        warn('Sheet with the provided name already exists.');\n        return false;\n      }\n      try {\n        var actualSheetName = this.engine.addSheet(sheetName !== null && sheetName !== void 0 ? sheetName : void 0);\n        if (sheetData) {\n          this.engine.setSheetContent(this.engine.getSheetId(actualSheetName), sheetData);\n        }\n        return actualSheetName;\n      } catch (e) {\n        warn(e.message);\n        return false;\n      }\n    }\n\n    /**\n     * Switch the sheet used as data in the Handsontable instance (it loads the data from the shared HyperFormula\n     * instance).\n     *\n     * @param {string} sheetName Sheet name used in the shared HyperFormula instance.\n     */\n  }, {\n    key: \"switchSheet\",\n    value: function switchSheet(sheetName) {\n      if (!this.engine.doesSheetExist(sheetName)) {\n        error(\"The sheet named `\".concat(sheetName, \"` does not exist, switch aborted.\"));\n        return;\n      }\n      this.sheetName = sheetName;\n      var serialized = this.engine.getSheetSerialized(this.sheetId);\n      if (serialized.length > 0) {\n        this.hot.loadData(serialized, \"\".concat(toUpperCaseFirst(PLUGIN_KEY), \".switchSheet\"));\n      }\n    }\n\n    /**\n     * Get the cell type under specified visual coordinates.\n     *\n     * @param {number} row Visual row index.\n     * @param {number} column Visual column index.\n     * @param {number} [sheet] The target sheet id, defaults to the current sheet.\n     * @returns {string} Possible values: 'FORMULA' | 'VALUE' | 'ARRAYFORMULA' | 'EMPTY'.\n     */\n  }, {\n    key: \"getCellType\",\n    value: function getCellType(row, column) {\n      var sheet = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.sheetId;\n      var physicalRow = this.hot.toPhysicalRow(row);\n      var physicalColumn = this.hot.toPhysicalColumn(column);\n      if (physicalRow !== null && physicalColumn !== null) {\n        return this.engine.getCellType({\n          sheet: sheet,\n          row: physicalRow,\n          col: physicalColumn\n        });\n      } else {\n        // Should return `EMPTY` when out of bounds (according to the test cases).\n        return 'EMPTY';\n      }\n    }\n\n    /**\n     * Returns `true` if under specified visual coordinates is formula.\n     *\n     * @param {number} row Visual row index.\n     * @param {number} column Visual column index.\n     * @param {number} [sheet] The target sheet id, defaults to the current sheet.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isFormulaCellType\",\n    value: function isFormulaCellType(row, column) {\n      var sheet = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.sheetId;\n      var physicalRow = this.hot.toPhysicalRow(row);\n      var physicalColumn = this.hot.toPhysicalColumn(column);\n      if (physicalRow === null || physicalColumn === null) {\n        return false;\n      }\n      return this.engine.doesCellHaveFormula({\n        sheet: sheet,\n        row: physicalRow,\n        col: physicalColumn\n      });\n    }\n\n    /**\n     * Renders dependent sheets (handsontable instances) based on the changes - list of the\n     * recalculated dependent cells.\n     *\n     * @private\n     * @param {object[]} dependentCells The values and location of applied changes within HF engine.\n     * @param {boolean} [renderSelf] `true` if it's supposed to render itself, `false` otherwise.\n     */\n  }, {\n    key: \"renderDependentSheets\",\n    value: function renderDependentSheets(dependentCells) {\n      var _this11 = this;\n      var renderSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var affectedSheetIds = new Set();\n      dependentCells.forEach(function (change) {\n        var _change$address;\n        // For the Named expression the address is empty, hence the `sheetId` is undefined.\n        var sheetId = change === null || change === void 0 ? void 0 : (_change$address = change.address) === null || _change$address === void 0 ? void 0 : _change$address.sheet;\n        if (sheetId !== void 0) {\n          if (!affectedSheetIds.has(sheetId)) {\n            affectedSheetIds.add(sheetId);\n          }\n        }\n      });\n      getRegisteredHotInstances(this.engine).forEach(function (relatedHot, sheetId) {\n        if ((renderSelf || sheetId !== _this11.sheetId) && affectedSheetIds.has(sheetId)) {\n          var _relatedHot$view;\n          relatedHot.render();\n          (_relatedHot$view = relatedHot.view) === null || _relatedHot$view === void 0 ? void 0 : _relatedHot$view.adjustElementsSize();\n        }\n      });\n    }\n\n    /**\n     * Validates dependent cells based on the cells that are modified by the change.\n     *\n     * @private\n     * @param {object[]} dependentCells The values and location of applied changes within HF engine.\n     * @param {object[]} [changedCells] The values and location of applied changes by developer (through API or UI).\n     */\n  }, {\n    key: \"validateDependentCells\",\n    value: function validateDependentCells(dependentCells) {\n      var _this12 = this;\n      var changedCells = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var stringifyAddress = function stringifyAddress(change) {\n        var _change$address2;\n        var _ref7 = (_change$address2 = change === null || change === void 0 ? void 0 : change.address) !== null && _change$address2 !== void 0 ? _change$address2 : {},\n          row = _ref7.row,\n          col = _ref7.col,\n          sheet = _ref7.sheet;\n        return isDefined(sheet) ? \"\".concat(sheet, \":\").concat(row, \"x\").concat(col) : '';\n      };\n      var changedCellsSet = new Set(changedCells.map(function (change) {\n        return stringifyAddress(change);\n      }));\n      dependentCells.forEach(function (change) {\n        var _change$address3, _change$address4;\n        var _ref8 = (_change$address3 = change.address) !== null && _change$address3 !== void 0 ? _change$address3 : {},\n          row = _ref8.row,\n          col = _ref8.col;\n        var visualRow = isDefined(row) ? _this12.hot.toVisualRow(row) : null;\n        var visualColumn = isDefined(col) ? _this12.hot.toVisualColumn(col) : null;\n\n        // Don't try to validate cells outside of the visual part of the table.\n        if (visualRow === null || visualColumn === null) {\n          return;\n        }\n\n        // For the Named expression the address is empty, hence the `sheetId` is undefined.\n        var sheetId = change === null || change === void 0 ? void 0 : (_change$address4 = change.address) === null || _change$address4 === void 0 ? void 0 : _change$address4.sheet;\n        var addressId = stringifyAddress(change);\n\n        // Validate the cells that depend on the calculated formulas. Skip that cells\n        // where the user directly changes the values - the Core triggers those validators.\n        if (sheetId !== void 0 && !changedCellsSet.has(addressId)) {\n          var boundHot = getRegisteredHotInstances(_this12.engine).get(sheetId);\n\n          // if `sheetId` is not bound to any Handsontable instance, skip the validation process\n          if (!boundHot) {\n            return;\n          }\n\n          // It will just re-render certain cell when necessary.\n          boundHot.validateCell(boundHot.getDataAtCell(visualRow, visualColumn), boundHot.getCellMeta(visualRow, visualColumn), function () {});\n        }\n      });\n    }\n\n    /**\n     * Sync a change from the change-related hooks with the engine.\n     *\n     * @private\n     * @param {number} row Visual row index.\n     * @param {number} column Visual column index.\n     * @param {Handsontable.CellValue} newValue New value.\n     * @returns {Array} Array of changes exported from the engine.\n     */\n  }, {\n    key: \"syncChangeWithEngine\",\n    value: function syncChangeWithEngine(row, column, newValue) {\n      var address = {\n        row: this.toPhysicalRowPosition(row),\n        col: this.toPhysicalColumnPosition(column),\n        sheet: this.sheetId\n      };\n      if (!this.engine.isItPossibleToSetCellContents(address)) {\n        warn(\"Not possible to set cell data at \".concat(JSON.stringify(address)));\n        return;\n      }\n      return this.engine.setCellContents(address, newValue);\n    }\n\n    /**\n     * The hook allows to translate the formula value to calculated value before it goes to the\n     * validator function.\n     *\n     * @private\n     * @param {*} value The cell value to validate.\n     * @param {number} visualRow The visual row index.\n     * @param {number|string} prop The visual column index or property name of the column.\n     * @returns {*} Returns value to validate.\n     */\n  }, {\n    key: \"onBeforeValidate\",\n    value: function onBeforeValidate(value, visualRow, prop) {\n      var visualColumn = this.hot.propToCol(prop);\n      if (this.isFormulaCellType(visualRow, visualColumn)) {\n        var address = {\n          row: this.hot.toPhysicalRow(visualRow),\n          col: this.hot.toPhysicalColumn(visualColumn),\n          sheet: this.sheetId\n        };\n        var cellValue = this.engine.getCellValue(address);\n\n        // If `cellValue` is an object it is expected to be an error\n        return _typeof(cellValue) === 'object' && cellValue !== null ? cellValue.value : cellValue;\n      }\n      return value;\n    }\n\n    /**\n     * `onBeforeAutofill` hook callback.\n     *\n     * @private\n     * @param {Array[]} fillData The data that was used to fill the `targetRange`. If `beforeAutofill` was used\n     * and returned `[[]]`, this will be the same object that was returned from `beforeAutofill`.\n     * @param {CellRange} sourceRange The range values will be filled from.\n     * @param {CellRange} targetRange The range new values will be filled into.\n     * @returns {boolean|*}\n     */\n  }, {\n    key: \"onBeforeAutofill\",\n    value: function onBeforeAutofill(fillData, sourceRange, targetRange) {\n      var _this13 = this;\n      var withSheetId = function withSheetId(range) {\n        return _objectSpread(_objectSpread({}, range), {}, {\n          sheet: _this13.sheetId\n        });\n      };\n      var engineSourceRange = {\n        start: withSheetId(sourceRange.getTopStartCorner()),\n        end: withSheetId(sourceRange.getBottomEndCorner())\n      };\n      var engineTargetRange = {\n        start: withSheetId(targetRange.getTopStartCorner()),\n        end: withSheetId(targetRange.getBottomEndCorner())\n      };\n\n      // Blocks the autofill operation if HyperFormula says that at least one of\n      // the underlying cell's contents cannot be set.\n      if (this.engine.isItPossibleToSetCellContents(engineTargetRange) === false) {\n        return false;\n      }\n      return this.engine.getFillRangeData(engineSourceRange, engineTargetRange);\n    }\n\n    /**\n     * `beforeLoadData` hook callback.\n     *\n     * @param {Array} sourceData Array of arrays or array of objects containing data.\n     * @param {boolean} initialLoad Flag that determines whether the data has been loaded during the initialization.\n     * @param {string} [source] Source of the call.\n     * @private\n     */\n  }, {\n    key: \"onBeforeLoadData\",\n    value: function onBeforeLoadData(sourceData, initialLoad) {\n      var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      if (source.includes(toUpperCaseFirst(PLUGIN_KEY))) {\n        return;\n      }\n\n      // This flag needs to be defined, because not passing data to HOT results in HOT auto-generating a `null`-filled\n      // initial dataset.\n      _classPrivateFieldSet(this, _hotWasInitializedWithEmptyData, isUndefined(this.hot.getSettings().data));\n    }\n\n    /**\n     * `afterLoadData` hook callback.\n     *\n     * @param {Array} sourceData Array of arrays or array of objects containing data.\n     * @param {boolean} initialLoad Flag that determines whether the data has been loaded during the initialization.\n     * @param {string} [source] Source of the call.\n     * @private\n     */\n  }, {\n    key: \"onAfterLoadData\",\n    value: function onAfterLoadData(sourceData, initialLoad) {\n      var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      if (source.includes(toUpperCaseFirst(PLUGIN_KEY))) {\n        return;\n      }\n      this.sheetName = setupSheet(this.engine, this.hot.getSettings()[PLUGIN_KEY].sheetName);\n      if (!_classPrivateFieldGet(this, _hotWasInitializedWithEmptyData)) {\n        var sourceDataArray = this.hot.getSourceDataArray();\n        if (this.engine.isItPossibleToReplaceSheetContent(this.sheetId, sourceDataArray)) {\n          _classPrivateFieldSet(this, _internalOperationPending, true);\n          var dependentCells = this.engine.setSheetContent(this.sheetId, this.hot.getSourceDataArray());\n          this.renderDependentSheets(dependentCells);\n          _classPrivateFieldSet(this, _internalOperationPending, false);\n        }\n      } else {\n        this.switchSheet(this.sheetName);\n      }\n    }\n\n    /**\n     * `modifyData` hook callback.\n     *\n     * @private\n     * @param {number} row Physical row height.\n     * @param {number} column Physical column index.\n     * @param {object} valueHolder Object which contains original value which can be modified by overwriting `.value`\n     *   property.\n     * @param {string} ioMode String which indicates for what operation hook is fired (`get` or `set`).\n     */\n  }, {\n    key: \"onModifyData\",\n    value: function onModifyData(row, column, valueHolder, ioMode) {\n      if (ioMode !== 'get' || _classPrivateFieldGet(this, _internalOperationPending) || this.sheetName === null || !this.engine.doesSheetExist(this.sheetName)) {\n        return;\n      }\n      var visualRow = this.hot.toVisualRow(row);\n\n      // `column` is here as visual index because of inconsistencies related to hook execution in `src/dataMap`.\n      var isFormulaCellType = this.isFormulaCellType(visualRow, column);\n      if (!isFormulaCellType) {\n        var cellType = this.getCellType(visualRow, column);\n        if (cellType !== 'ARRAY') {\n          if (isEscapedFormulaExpression(valueHolder.value)) {\n            valueHolder.value = unescapeFormulaExpression(valueHolder.value);\n          }\n          return;\n        }\n      }\n\n      // `toPhysicalColumn` is here because of inconsistencies related to hook execution in `DataMap`.\n      var address = {\n        row: row,\n        col: this.toPhysicalColumnPosition(column),\n        sheet: this.sheetId\n      };\n      var cellValue = this.engine.getCellValue(address);\n\n      // If `cellValue` is an object it is expected to be an error\n      var value = _typeof(cellValue) === 'object' && cellValue !== null ? cellValue.value : cellValue;\n      valueHolder.value = value;\n    }\n\n    /**\n     * `modifySourceData` hook callback.\n     *\n     * @private\n     * @param {number} row Physical row index.\n     * @param {number|string} columnOrProp Physical column index or prop.\n     * @param {object} valueHolder Object which contains original value which can be modified by overwriting `.value`\n     *   property.\n     * @param {string} ioMode String which indicates for what operation hook is fired (`get` or `set`).\n     */\n  }, {\n    key: \"onModifySourceData\",\n    value: function onModifySourceData(row, columnOrProp, valueHolder, ioMode) {\n      if (ioMode !== 'get' || _classPrivateFieldGet(this, _internalOperationPending) || this.sheetName === null || !this.engine.doesSheetExist(this.sheetName)) {\n        return;\n      }\n      var visualRow = this.hot.toVisualRow(row);\n      var visualColumn = this.hot.propToCol(columnOrProp);\n\n      // `column` is here as visual index because of inconsistencies related to hook execution in `src/dataMap`.\n      var isFormulaCellType = this.isFormulaCellType(visualRow, visualColumn);\n      if (!isFormulaCellType) {\n        var cellType = this.getCellType(visualRow, visualColumn);\n        if (cellType !== 'ARRAY') {\n          return;\n        }\n      }\n      var dimensions = this.engine.getSheetDimensions(this.engine.getSheetId(this.sheetName));\n\n      // Don't actually change the source data if HyperFormula is not\n      // initialized yet. This is done to allow the `afterLoadData` hook to\n      // load the existing source data with `Handsontable#getSourceDataArray`\n      // properly.\n      if (dimensions.width === 0 && dimensions.height === 0) {\n        return;\n      }\n      var address = {\n        row: row,\n        // Workaround for inconsistencies in `src/dataSource.js`\n        col: this.toPhysicalColumnPosition(visualColumn),\n        sheet: this.sheetId\n      };\n      valueHolder.value = this.engine.getCellSerialized(address);\n    }\n\n    /**\n     * `onAfterSetDataAtCell` hook callback.\n     *\n     * @private\n     * @param {Array[]} changes An array of changes in format [[row, prop, oldValue, value], ...].\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link http://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).\n     */\n  }, {\n    key: \"onAfterSetDataAtCell\",\n    value: function onAfterSetDataAtCell(changes, source) {\n      var _this14 = this;\n      if (isBlockedSource(source)) {\n        return;\n      }\n      var outOfBoundsChanges = [];\n      var changedCells = [];\n      var dependentCells = this.engine.batch(function () {\n        changes.forEach(function (_ref9) {\n          var _ref10 = _slicedToArray(_ref9, 4),\n            row = _ref10[0],\n            prop = _ref10[1],\n            newValue = _ref10[3];\n          var column = _this14.hot.propToCol(prop);\n          var physicalRow = _this14.hot.toPhysicalRow(row);\n          var physicalColumn = _this14.hot.toPhysicalColumn(column);\n          var address = {\n            row: physicalRow,\n            col: physicalColumn,\n            sheet: _this14.sheetId\n          };\n          if (physicalRow !== null && physicalColumn !== null) {\n            _this14.syncChangeWithEngine(row, column, newValue);\n          } else {\n            outOfBoundsChanges.push([row, column, newValue]);\n          }\n          changedCells.push({\n            address: address\n          });\n        });\n      });\n      if (outOfBoundsChanges.length) {\n        // Workaround for rows/columns being created two times (by HOT and the engine).\n        // (unfortunately, this requires an extra re-render)\n        this.hot.addHookOnce('afterChange', function () {\n          var outOfBoundsDependentCells = _this14.engine.batch(function () {\n            outOfBoundsChanges.forEach(function (_ref11) {\n              var _ref12 = _slicedToArray(_ref11, 3),\n                row = _ref12[0],\n                column = _ref12[1],\n                newValue = _ref12[2];\n              _this14.syncChangeWithEngine(row, column, newValue);\n            });\n          });\n          _this14.renderDependentSheets(outOfBoundsDependentCells, true);\n        });\n      }\n      this.renderDependentSheets(dependentCells);\n      this.validateDependentCells(dependentCells, changedCells);\n    }\n\n    /**\n     * `onAfterSetSourceDataAtCell` hook callback.\n     *\n     * @private\n     * @param {Array[]} changes An array of changes in format [[row, column, oldValue, value], ...].\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link http://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).\n     */\n  }, {\n    key: \"onAfterSetSourceDataAtCell\",\n    value: function onAfterSetSourceDataAtCell(changes, source) {\n      var _this15 = this;\n      if (isBlockedSource(source)) {\n        return;\n      }\n      var dependentCells = [];\n      var changedCells = [];\n      changes.forEach(function (_ref13) {\n        var _ref14 = _slicedToArray(_ref13, 4),\n          row = _ref14[0],\n          prop = _ref14[1],\n          newValue = _ref14[3];\n        var column = _this15.hot.propToCol(prop);\n        if (!isNumeric(column)) {\n          return;\n        }\n        var address = {\n          row: row,\n          col: _this15.toPhysicalColumnPosition(column),\n          sheet: _this15.sheetId\n        };\n        if (!_this15.engine.isItPossibleToSetCellContents(address)) {\n          warn(\"Not possible to set source cell data at \".concat(JSON.stringify(address)));\n          return;\n        }\n        changedCells.push({\n          address: address\n        });\n        dependentCells.push.apply(dependentCells, _toConsumableArray(_this15.engine.setCellContents(address, newValue)));\n      });\n      this.renderDependentSheets(dependentCells);\n      this.validateDependentCells(dependentCells, changedCells);\n    }\n\n    /**\n     * `beforeCreateRow` hook callback.\n     *\n     * @private\n     * @param {number} row Represents the visual index of first newly created row in the data source array.\n     * @param {number} amount Number of newly created rows in the data source array.\n     * @returns {*|boolean} If false is returned the action is canceled.\n     */\n  }, {\n    key: \"onBeforeCreateRow\",\n    value: function onBeforeCreateRow(row, amount) {\n      if (this.sheetId === null || !this.engine.doesSheetExist(this.sheetName) || !this.engine.isItPossibleToAddRows(this.sheetId, [this.toPhysicalRowPosition(row), amount])) {\n        return false;\n      }\n    }\n\n    /**\n     * `beforeCreateCol` hook callback.\n     *\n     * @private\n     * @param {number} col Represents the visual index of first newly created column in the data source.\n     * @param {number} amount Number of newly created columns in the data source.\n     * @returns {*|boolean} If false is returned the action is canceled.\n     */\n  }, {\n    key: \"onBeforeCreateCol\",\n    value: function onBeforeCreateCol(col, amount) {\n      if (this.sheetId === null || !this.engine.doesSheetExist(this.sheetName) || !this.engine.isItPossibleToAddColumns(this.sheetId, [this.toPhysicalColumnPosition(col), amount])) {\n        return false;\n      }\n    }\n\n    /**\n     * `beforeRemoveRow` hook callback.\n     *\n     * @private\n     * @param {number} row Visual index of starter row.\n     * @param {number} amount Amount of rows to be removed.\n     * @param {number[]} physicalRows An array of physical rows removed from the data source.\n     * @returns {*|boolean} If false is returned the action is canceled.\n     */\n  }, {\n    key: \"onBeforeRemoveRow\",\n    value: function onBeforeRemoveRow(row, amount, physicalRows) {\n      var _this16 = this;\n      var possible = physicalRows.every(function (physicalRow) {\n        return _this16.engine.isItPossibleToRemoveRows(_this16.sheetId, [physicalRow, 1]);\n      });\n      return possible === false ? false : void 0;\n    }\n\n    /**\n     * `beforeRemoveCol` hook callback.\n     *\n     * @private\n     * @param {number} col Visual index of starter column.\n     * @param {number} amount Amount of columns to be removed.\n     * @param {number[]} physicalColumns An array of physical columns removed from the data source.\n     * @returns {*|boolean} If false is returned the action is canceled.\n     */\n  }, {\n    key: \"onBeforeRemoveCol\",\n    value: function onBeforeRemoveCol(col, amount, physicalColumns) {\n      var _this17 = this;\n      var possible = physicalColumns.every(function (physicalColumn) {\n        return _this17.engine.isItPossibleToRemoveColumns(_this17.sheetId, [physicalColumn, 1]);\n      });\n      return possible === false ? false : void 0;\n    }\n\n    /**\n     * `afterCreateRow` hook callback.\n     *\n     * @private\n     * @param {number} row Represents the visual index of first newly created row in the data source array.\n     * @param {number} amount Number of newly created rows in the data source array.\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link http://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).\n     */\n  }, {\n    key: \"onAfterCreateRow\",\n    value: function onAfterCreateRow(row, amount, source) {\n      if (isBlockedSource(source)) {\n        return;\n      }\n      var changes = this.engine.addRows(this.sheetId, [this.toPhysicalRowPosition(row), amount]);\n      this.renderDependentSheets(changes);\n    }\n\n    /**\n     * `afterCreateCol` hook callback.\n     *\n     * @private\n     * @param {number} col Represents the visual index of first newly created column in the data source.\n     * @param {number} amount Number of newly created columns in the data source.\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link http://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).\n     */\n  }, {\n    key: \"onAfterCreateCol\",\n    value: function onAfterCreateCol(col, amount, source) {\n      if (isBlockedSource(source)) {\n        return;\n      }\n      var changes = this.engine.addColumns(this.sheetId, [this.toPhysicalColumnPosition(col), amount]);\n      this.renderDependentSheets(changes);\n    }\n\n    /**\n     * `afterRemoveRow` hook callback.\n     *\n     * @private\n     * @param {number} row Visual index of starter row.\n     * @param {number} amount An amount of removed rows.\n     * @param {number[]} physicalRows An array of physical rows removed from the data source.\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link http://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).\n     */\n  }, {\n    key: \"onAfterRemoveRow\",\n    value: function onAfterRemoveRow(row, amount, physicalRows, source) {\n      var _this18 = this;\n      if (isBlockedSource(source)) {\n        return;\n      }\n      var descendingPhysicalRows = physicalRows.sort().reverse();\n      var changes = this.engine.batch(function () {\n        descendingPhysicalRows.forEach(function (physicalRow) {\n          _this18.engine.removeRows(_this18.sheetId, [physicalRow, 1]);\n        });\n      });\n      this.renderDependentSheets(changes);\n    }\n\n    /**\n     * `afterRemoveCol` hook callback.\n     *\n     * @private\n     * @param {number} col Visual index of starter column.\n     * @param {number} amount An amount of removed columns.\n     * @param {number[]} physicalColumns An array of physical columns removed from the data source.\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link http://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).\n     */\n  }, {\n    key: \"onAfterRemoveCol\",\n    value: function onAfterRemoveCol(col, amount, physicalColumns, source) {\n      var _this19 = this;\n      if (isBlockedSource(source)) {\n        return;\n      }\n      var descendingPhysicalColumns = physicalColumns.sort().reverse();\n      var changes = this.engine.batch(function () {\n        descendingPhysicalColumns.forEach(function (physicalColumn) {\n          _this19.engine.removeColumns(_this19.sheetId, [physicalColumn, 1]);\n        });\n      });\n      this.renderDependentSheets(changes);\n    }\n\n    /**\n     * `afterDetachChild` hook callback.\n     * Used to sync the data of the rows detached in the Nested Rows plugin with the engine's dataset.\n     *\n     * @private\n     * @param {object} parent An object representing the parent from which the element was detached.\n     * @param {object} element The detached element.\n     * @param {number} finalElementRowIndex The final row index of the detached element.\n     */\n  }, {\n    key: \"onAfterDetachChild\",\n    value: function onAfterDetachChild(parent, element, finalElementRowIndex) {\n      var _element$__children,\n        _this20 = this;\n      _classPrivateFieldSet(this, _internalOperationPending, true);\n      var rowsData = this.hot.getSourceDataArray(finalElementRowIndex, 0, finalElementRowIndex + (((_element$__children = element.__children) === null || _element$__children === void 0 ? void 0 : _element$__children.length) || 0), this.hot.countSourceCols());\n      _classPrivateFieldSet(this, _internalOperationPending, false);\n      rowsData.forEach(function (row, relativeRowIndex) {\n        row.forEach(function (value, colIndex) {\n          _this20.engine.setCellContents({\n            col: colIndex,\n            row: finalElementRowIndex + relativeRowIndex,\n            sheet: _this20.sheetId\n          }, [[value]]);\n        });\n      });\n    }\n\n    /**\n     * Called when a value is updated in the engine.\n     *\n     * @private\n     * @fires Hooks#afterFormulasValuesUpdate\n     * @param {Array} changes The values and location of applied changes.\n     */\n  }, {\n    key: \"onEngineValuesUpdated\",\n    value: function onEngineValuesUpdated(changes) {\n      this.hot.runHooks('afterFormulasValuesUpdate', changes);\n    }\n\n    /**\n     * Called when a named expression is added to the engine instance.\n     *\n     * @private\n     * @fires Hooks#afterNamedExpressionAdded\n     * @param {string} namedExpressionName The name of the added expression.\n     * @param {Array} changes The values and location of applied changes.\n     */\n  }, {\n    key: \"onEngineNamedExpressionsAdded\",\n    value: function onEngineNamedExpressionsAdded(namedExpressionName, changes) {\n      this.hot.runHooks('afterNamedExpressionAdded', namedExpressionName, changes);\n    }\n\n    /**\n     * Called when a named expression is removed from the engine instance.\n     *\n     * @private\n     * @fires Hooks#afterNamedExpressionRemoved\n     * @param {string} namedExpressionName The name of the removed expression.\n     * @param {Array} changes The values and location of applied changes.\n     */\n  }, {\n    key: \"onEngineNamedExpressionsRemoved\",\n    value: function onEngineNamedExpressionsRemoved(namedExpressionName, changes) {\n      this.hot.runHooks('afterNamedExpressionRemoved', namedExpressionName, changes);\n    }\n\n    /**\n     * Called when a new sheet is added to the engine instance.\n     *\n     * @private\n     * @fires Hooks#afterSheetAdded\n     * @param {string} addedSheetDisplayName The name of the added sheet.\n     */\n  }, {\n    key: \"onEngineSheetAdded\",\n    value: function onEngineSheetAdded(addedSheetDisplayName) {\n      this.hot.runHooks('afterSheetAdded', addedSheetDisplayName);\n    }\n\n    /**\n     * Called when a sheet in the engine instance is renamed.\n     *\n     * @private\n     * @fires Hooks#afterSheetRenamed\n     * @param {string} oldDisplayName The old name of the sheet.\n     * @param {string} newDisplayName The new name of the sheet.\n     */\n  }, {\n    key: \"onEngineSheetRenamed\",\n    value: function onEngineSheetRenamed(oldDisplayName, newDisplayName) {\n      this.hot.runHooks('afterSheetRenamed', oldDisplayName, newDisplayName);\n    }\n\n    /**\n     * Called when a sheet is removed from the engine instance.\n     *\n     * @private\n     * @fires Hooks#afterSheetRemoved\n     * @param {string} removedSheetDisplayName The removed sheet name.\n     * @param {Array} changes The values and location of applied changes.\n     */\n  }, {\n    key: \"onEngineSheetRemoved\",\n    value: function onEngineSheetRemoved(removedSheetDisplayName, changes) {\n      this.hot.runHooks('afterSheetRemoved', removedSheetDisplayName, changes);\n    }\n  }], [{\n    key: \"PLUGIN_KEY\",\n    get: function get() {\n      return PLUGIN_KEY;\n    }\n  }, {\n    key: \"PLUGIN_PRIORITY\",\n    get: function get() {\n      return PLUGIN_PRIORITY;\n    }\n\n    /**\n     * Flag used to bypass hooks in internal operations.\n     *\n     * @private\n     * @type {boolean}\n     */\n  }]);\n  return Formulas;\n}(BasePlugin);"],"mappings":"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"},"metadata":{},"sourceType":"module"}