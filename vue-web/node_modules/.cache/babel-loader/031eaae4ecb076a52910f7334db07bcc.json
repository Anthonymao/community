{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\n\nimport { toUpperCaseFirst } from \"../helpers/string.mjs\";\nimport { isFunction } from \"../helpers/function.mjs\";\nimport DataMap from \"./dataMap.mjs\";\nimport { deepClone } from \"../helpers/object.mjs\";\n/**\n * Loads new data to Handsontable.\n *\n * @private\n * @param {Array} data Array of arrays or array of objects containing data.\n * @param {Function} setDataMapFunction Function that updates the datamap instance.\n * @param {Function} callbackFunction Function that takes care of updating Handsontable to the new dataset. Called\n * right before the `after-` hooks.\n * @param {object} config The configuration object containing all the needed dependency references and information.\n * @param {Handsontable.Core} config.hotInstance The Handsontable instance.\n * @param {DataMap} config.dataMap The current `dataMap` instance.\n * @param {DataSource} config.dataSource The current `dataSource` instance.\n * @param {string} config.internalSource The immediate internal source of the `replaceData` call.\n * @param {string} config.source The source of the call.\n * @param {boolean} config.firstRun `true` if it's a first call in the Handsontable lifecycle, `false` otherwise.\n * @fires Hooks#beforeLoadData\n * @fires Hooks#beforeUpdateData\n * @fires Hooks#afterLoadData\n * @fires Hooks#afterUpdateData\n * @fires Hooks#afterChange\n */\n\nfunction replaceData(data, setDataMapFunction, callbackFunction, config) {\n  var hotInstance = config.hotInstance,\n      dataMap = config.dataMap,\n      dataSource = config.dataSource,\n      internalSource = config.internalSource,\n      source = config.source,\n      firstRun = config.firstRun;\n  var capitalizedInternalSource = toUpperCaseFirst(internalSource);\n  var tableMeta = hotInstance.getSettings();\n\n  if (Array.isArray(tableMeta.dataSchema)) {\n    hotInstance.dataType = 'array';\n  } else if (isFunction(tableMeta.dataSchema)) {\n    hotInstance.dataType = 'function';\n  } else {\n    hotInstance.dataType = 'object';\n  }\n\n  if (dataMap) {\n    dataMap.destroy();\n  }\n\n  data = hotInstance.runHooks(\"before\".concat(capitalizedInternalSource), data, firstRun, source);\n  var newDataMap = new DataMap(hotInstance, data, tableMeta); // We need to apply the new dataMap immediately, because of some asynchronous logic in the\n  // `autoRowSize`/`autoColumnSize` plugins.\n\n  setDataMapFunction(newDataMap);\n\n  if (_typeof(data) === 'object' && data !== null) {\n    if (!(data.push && data.splice)) {\n      // check if data is array. Must use duck-type check so Backbone Collections also pass it\n      // when data is not an array, attempt to make a single-row array of it\n      // eslint-disable-next-line no-param-reassign\n      data = [data];\n    }\n  } else if (data === null) {\n    var dataSchema = newDataMap.getSchema(); // eslint-disable-next-line no-param-reassign\n\n    data = [];\n    var row;\n    var r = 0;\n    var rlen = 0;\n\n    for (r = 0, rlen = tableMeta.startRows; r < rlen; r++) {\n      if ((hotInstance.dataType === 'object' || hotInstance.dataType === 'function') && tableMeta.dataSchema) {\n        row = deepClone(dataSchema);\n        data.push(row);\n      } else if (hotInstance.dataType === 'array') {\n        row = deepClone(dataSchema[0]);\n        data.push(row);\n      } else {\n        row = [];\n\n        for (var c = 0, clen = tableMeta.startCols; c < clen; c++) {\n          row.push(null);\n        }\n\n        data.push(row);\n      }\n    }\n  } else {\n    throw new Error(\"\".concat(internalSource, \" only accepts array of objects or array of arrays (\").concat(_typeof(data), \" given)\"));\n  }\n\n  if (Array.isArray(data[0])) {\n    hotInstance.dataType = 'array';\n  }\n\n  tableMeta.data = data;\n  newDataMap.dataSource = data;\n  dataSource.data = data;\n  dataSource.dataType = hotInstance.dataType;\n  dataSource.colToProp = newDataMap.colToProp.bind(newDataMap);\n  dataSource.propToCol = newDataMap.propToCol.bind(newDataMap);\n  dataSource.countCachedColumns = newDataMap.countCachedColumns.bind(newDataMap); // Run the logic for reassuring that the table structure fits the new dataset.\n\n  callbackFunction(newDataMap);\n  hotInstance.runHooks(\"after\".concat(capitalizedInternalSource), data, firstRun, source); // TODO: rethink the way the `afterChange` hook is being run here in the core `init` method.\n\n  if (!firstRun) {\n    hotInstance.runHooks('afterChange', null, internalSource);\n    hotInstance.render();\n  }\n}\n\nexport { replaceData };","map":{"version":3,"names":["_typeof","obj","Symbol","iterator","constructor","prototype","toUpperCaseFirst","isFunction","DataMap","deepClone","replaceData","data","setDataMapFunction","callbackFunction","config","hotInstance","dataMap","dataSource","internalSource","source","firstRun","capitalizedInternalSource","tableMeta","getSettings","Array","isArray","dataSchema","dataType","destroy","runHooks","concat","newDataMap","push","splice","getSchema","row","r","rlen","startRows","c","clen","startCols","Error","colToProp","bind","propToCol","countCachedColumns","render"],"sources":["/home/ubuntu/community/vue-web/node_modules/handsontable/dataMap/replaceData.mjs"],"sourcesContent":["import \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nimport { toUpperCaseFirst } from \"../helpers/string.mjs\";\nimport { isFunction } from \"../helpers/function.mjs\";\nimport DataMap from \"./dataMap.mjs\";\nimport { deepClone } from \"../helpers/object.mjs\"; /**\n                                                    * Loads new data to Handsontable.\n                                                    *\n                                                    * @private\n                                                    * @param {Array} data Array of arrays or array of objects containing data.\n                                                    * @param {Function} setDataMapFunction Function that updates the datamap instance.\n                                                    * @param {Function} callbackFunction Function that takes care of updating Handsontable to the new dataset. Called\n                                                    * right before the `after-` hooks.\n                                                    * @param {object} config The configuration object containing all the needed dependency references and information.\n                                                    * @param {Handsontable.Core} config.hotInstance The Handsontable instance.\n                                                    * @param {DataMap} config.dataMap The current `dataMap` instance.\n                                                    * @param {DataSource} config.dataSource The current `dataSource` instance.\n                                                    * @param {string} config.internalSource The immediate internal source of the `replaceData` call.\n                                                    * @param {string} config.source The source of the call.\n                                                    * @param {boolean} config.firstRun `true` if it's a first call in the Handsontable lifecycle, `false` otherwise.\n                                                    * @fires Hooks#beforeLoadData\n                                                    * @fires Hooks#beforeUpdateData\n                                                    * @fires Hooks#afterLoadData\n                                                    * @fires Hooks#afterUpdateData\n                                                    * @fires Hooks#afterChange\n                                                    */\nfunction replaceData(data, setDataMapFunction, callbackFunction, config) {\n  var hotInstance = config.hotInstance,\n    dataMap = config.dataMap,\n    dataSource = config.dataSource,\n    internalSource = config.internalSource,\n    source = config.source,\n    firstRun = config.firstRun;\n  var capitalizedInternalSource = toUpperCaseFirst(internalSource);\n  var tableMeta = hotInstance.getSettings();\n  if (Array.isArray(tableMeta.dataSchema)) {\n    hotInstance.dataType = 'array';\n  } else if (isFunction(tableMeta.dataSchema)) {\n    hotInstance.dataType = 'function';\n  } else {\n    hotInstance.dataType = 'object';\n  }\n  if (dataMap) {\n    dataMap.destroy();\n  }\n  data = hotInstance.runHooks(\"before\".concat(capitalizedInternalSource), data, firstRun, source);\n  var newDataMap = new DataMap(hotInstance, data, tableMeta);\n\n  // We need to apply the new dataMap immediately, because of some asynchronous logic in the\n  // `autoRowSize`/`autoColumnSize` plugins.\n  setDataMapFunction(newDataMap);\n  if (_typeof(data) === 'object' && data !== null) {\n    if (!(data.push && data.splice)) {\n      // check if data is array. Must use duck-type check so Backbone Collections also pass it\n      // when data is not an array, attempt to make a single-row array of it\n      // eslint-disable-next-line no-param-reassign\n      data = [data];\n    }\n  } else if (data === null) {\n    var dataSchema = newDataMap.getSchema();\n\n    // eslint-disable-next-line no-param-reassign\n    data = [];\n    var row;\n    var r = 0;\n    var rlen = 0;\n    for (r = 0, rlen = tableMeta.startRows; r < rlen; r++) {\n      if ((hotInstance.dataType === 'object' || hotInstance.dataType === 'function') && tableMeta.dataSchema) {\n        row = deepClone(dataSchema);\n        data.push(row);\n      } else if (hotInstance.dataType === 'array') {\n        row = deepClone(dataSchema[0]);\n        data.push(row);\n      } else {\n        row = [];\n        for (var c = 0, clen = tableMeta.startCols; c < clen; c++) {\n          row.push(null);\n        }\n        data.push(row);\n      }\n    }\n  } else {\n    throw new Error(\"\".concat(internalSource, \" only accepts array of objects or array of arrays (\").concat(_typeof(data), \" given)\"));\n  }\n  if (Array.isArray(data[0])) {\n    hotInstance.dataType = 'array';\n  }\n  tableMeta.data = data;\n  newDataMap.dataSource = data;\n  dataSource.data = data;\n  dataSource.dataType = hotInstance.dataType;\n  dataSource.colToProp = newDataMap.colToProp.bind(newDataMap);\n  dataSource.propToCol = newDataMap.propToCol.bind(newDataMap);\n  dataSource.countCachedColumns = newDataMap.countCachedColumns.bind(newDataMap);\n\n  // Run the logic for reassuring that the table structure fits the new dataset.\n  callbackFunction(newDataMap);\n  hotInstance.runHooks(\"after\".concat(capitalizedInternalSource), data, firstRun, source);\n\n  // TODO: rethink the way the `afterChange` hook is being run here in the core `init` method.\n  if (!firstRun) {\n    hotInstance.runHooks('afterChange', null, internalSource);\n    hotInstance.render();\n  }\n}\nexport { replaceData };"],"mappings":"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"},"metadata":{},"sourceType":"module"}